
const TRANSLATIONS = {
    zh: {
        page_title: "å›¢å­ç”»æ¿ï¼šç»„ç»‡çµæ„Ÿï¼Œä¸€ç›®äº†ç„¶",
        brand_name: "å›¢å­ç”»æ¿",
        lang_toggle: "EN",
        lang_tooltip: "åˆ‡æ¢è‡³è‹±æ–‡",
        input_placeholder: "è¾“å…¥æƒ³æ³•... (ç©ºæ ¼/é€—å·/æ¢è¡Œåˆ†éš”)",
        btn_add: "âœ¨ ç”ŸæˆèŠ‚ç‚¹ âœ¨",
        btn_export: "å¯¼å‡º",
        btn_import: "å¯¼å…¥",
        confirm_clear: "ç¡®å®š?",
        help_undo: "æ’¤é”€ / é‡åš",
        help_pan: "å¹³ç§»ç”»å¸ƒ",
        help_zoom: "ç¼©æ”¾",
        help_edit: "ç¼–è¾‘ / å¤šé€‰",
        help_copy: "å¤åˆ¶ / ç²˜è´´",
        help_group: "ç¼–ç»„ / è§£ç»„",
        help_link: "è¿çº¿",
        help_align: "å¯¹é½",
        help_color: "åˆ‡æ¢é¢œè‰²",
        alert_file_err: "æ–‡ä»¶æ ¼å¼é”™è¯¯",
        settings_tooltip: "è®¾ç½®",
        settings_precise: "ç²¾å‡†æ˜ å°„",
        settings_hide_grid: "éšè—ç½‘æ ¼ç‚¹",
        help_tooltip: "å¸®åŠ©/å¿«æ·é”®",
        settings_alt_as_ctrl: "Alt å…¼ä»» Ctrl",
        btn_export: "å¯¼å‡º",
        settings_hand_drawn: "æ‰‹å†™é£æ ¼",
        empty_prompt: "è¾“å…¥æƒ³æ³•ï¼Œå¼€å¯ä½ çš„ç”»å¸ƒ âœ¨",
        toast_cleared: "ç”»å¸ƒå·²æ¸…ç©º",
        toast_imported: "ç”»å¸ƒå·²å¯¼å…¥",
        toast_undo: "æ’¤é”€",
        toast_export_prev: "å¯¼å‡ºåˆšåˆšçš„å¤‡ä»½ âœ¨",
        toast_import_success: "å¯¼å…¥æˆåŠŸ âœ¨",
        help_delete: "åˆ é™¤é€‰ä¸­",
        help_home: "å›å½’ä¸­å¿ƒ",
        help_undo: "æ’¤é”€ / é‡åš",
        help_pan_zoom: "å¹³ç§» / ç¼©æ”¾",
        help_center: "å›å½’è§†å›¾ä¸­å¿ƒ",
        help_save: "ä¿å­˜ç”»æ¿æ–‡ä»¶",
        help_center_align: "åˆ†å¸ƒå¯¹é½",
        help_clone: "å…‹éš†é€‰ä¸­èŠ‚ç‚¹",
        help_select: "å¤šé€‰ / æ¡†é€‰",
        help_delete: "åˆ é™¤é€‰ä¸­",
        help_nudge: "å¾®è°ƒä½ç½®",
        btn_export_link: "é“¾æ¥",
        btn_export_file: "æ–‡ä»¶",
        btn_export_svg: "çŸ¢é‡å›¾",
        btn_export_png: "å›¾ç‰‡",
        help_group: "ç¼–ç»„ / è§£ç»„",
        help_link: "è¿çº¿ / æ–­çº¿",
        help_align: "æ–¹å‘å¯¹é½",
        help_color: "åˆ‡æ¢é¢œè‰²",
        about_title: "å…³äº",
        feedback: "åé¦ˆ",
        about_desc: "ç®€å•ã€ä¼˜é›…çš„æ¦‚å¿µå…³ç³»å¯è§†åŒ–å·¥å…·ã€‚\n\nç»„ç»‡çµæ„Ÿï¼Œä¸€ç›®äº†ç„¶ã€‚",
        star_on_github: "åœ¨ GitHub ä¸Šç‚¹æ˜Ÿæ”¯æŒ",
        blog_link: "å¼€å‘åšå®¢",
        buy_coffee: "è¯·å–å’–å•¡",
        alert_file_err: "æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼Œè¯·ä¸Šä¼  .dango æ–‡ä»¶",
        settings_copy_mode: "å¤åˆ¶ä»£æ›¿ä¸‹è½½",
        toast_copy_success: "å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ âœ¨",
        toast_copy_fail: "æµè§ˆå™¨é™åˆ¶ï¼Œå¤åˆ¶å¤±è´¥",
        help_spotlight: "èšå…‰ç¯",
    },
    en: {
        page_title: "Dango: Drop a nugget, get organized",
        brand_name: "Dango",
        lang_toggle: "ä¸­",
        lang_tooltip: "Switch to Chinese",
        input_placeholder: "Enter ideas... (Space/Comma/Newline)",
        btn_add: "âœ¨ Create Nodes âœ¨",
        btn_export: "Export",
        btn_import: "Import",
        confirm_clear: "Sure?",
        help_undo: "Undo / Redo",
        help_pan: "Pan Canvas",
        help_zoom: "Zoom",
        help_edit: "Edit / Multi-select",
        help_copy: "Copy / Paste",
        help_group: "Group / Ungroup",
        help_link: "Link Nodes",
        help_align: "Align",
        help_color: "Change Color",
        alert_file_err: "Invalid file format",
        settings_tooltip: "Settings",
        settings_precise: "Precise Mapping",
        settings_hide_grid: "Hide Grid Dots",
        help_tooltip: "Help / Shortcut",
        settings_alt_as_ctrl: "Alt as Ctrl modifier",
        btn_export: "Export",
        settings_hand_drawn: "Hand-drawn Style",
        empty_prompt: "Type ideas here to start âœ¨",
        toast_cleared: "Canvas cleared",
        toast_imported: "Canvas imported",
        toast_undo: "Undo",
        toast_export_prev: "Export Backup âœ¨",
        toast_import_success: "Imported successfully âœ¨",
        help_delete: "Delete Selected",
        help_home: "Back to Center",
        help_undo: "Undo / Redo",
        help_pan_zoom: "Pan / Zoom",
        help_center: "Reset View",
        help_save: "Save Dango File",
        help_center_align: "Align Distribution",
        help_clone: "Clone Selection",
        help_select: "Multi-select",
        help_delete: "Delete Selected",
        help_nudge: "Nudge Position",
        btn_export_link: "LINK",
        btn_export_file: "FILE",
        btn_export_svg: "SVG",
        btn_export_png: "PNG",
        help_group: "Group / Ungroup",
        help_link: "Link / Unlink",
        help_align: "Align Direction",
        help_color: "Change Color",
        about_title: "About",
        feedback: "Feedback",
        about_desc: "Drop a nugget, get organized.",
        star_on_github: "Star on GitHub",
        blog_link: "Dev Blog",
        buy_coffee: "Buy me a coffee",
        alert_file_err: "Invalid format, please upload .dango file",
        settings_copy_mode: "Copy PNG to clipboard (No download)",
        toast_copy_success: "High-res image copied to clipboard âœ¨",
        toast_copy_fail: "Copy failed by browser limit",
        help_spotlight: "Spotlight",
    }
};

// ç®€å•çš„çº¯é“¾æ¥åˆ¤æ–­ (ä»¥ http, https æˆ– www å¼€å¤´ï¼Œä¸”ä¸å«ç©ºæ ¼)
function isUrl(str) {
    return /^(https?:\/\/|www\.)\S+$/i.test(str.trim());
}
// --- ä¿®æ”¹åˆå§‹åŒ–é€»è¾‘ ---
const LS_LANG_KEY = 'cc-lang';
// ä¼˜å…ˆä»æœ¬åœ°ç¼“å­˜è¯»å–ï¼Œå…¶æ¬¡æ£€æµ‹æµè§ˆå™¨è¯­è¨€ï¼ˆåªæ”¯æŒä¸­è‹±ï¼Œå…¶ä½™é»˜è®¤è‹±ï¼‰
let currentLang = localStorage.getItem(LS_LANG_KEY) ||
    (navigator.language.startsWith('zh') ? 'zh' : 'en');
// 2. å…³äºå¼¹çª—é€»è¾‘
const aboutOverlay = document.getElementById('about-overlay');
const btnTriggerAbout = document.getElementById('trigger-about');
const btnCloseAbout = document.getElementById('btn-close-about');

// æ‰“å¼€å…³äº
btnTriggerAbout.onclick = (e) => {
    e.stopPropagation();
    
    // 1. å…³é—­å¸®åŠ©èœå•çš„æ˜¾ç¤ºçŠ¶æ€
    els.helpModal.classList.remove('show');
    els.btnHelp.classList.remove('active');
    
    // 2. âœ¨ æ ¸å¿ƒä¿®å¤ï¼šè®©æŒ‰é’®å¤±å»ç„¦ç‚¹
    // è¿™ä¼šæ‰“ç ´ CSS çš„ #ui-layer:focus-within è§„åˆ™ï¼Œ
    // å¯¼è‡´å·¦ä¸Šè§’çš„å¤§é¢æ¿è‡ªåŠ¨ç¼©å›æˆä¸€ä¸ªå°èƒ¶å›Š
    btnTriggerAbout.blur(); 
    
    // 3. æ‰“å¼€å…³äºå¼¹çª—
    aboutOverlay.classList.add('show');
};

// å…³é—­å…³äº
function closeAbout() {
    aboutOverlay.classList.remove('show');
}
btnCloseAbout.onclick = closeAbout;
aboutOverlay.onclick = (e) => {
    // ç‚¹å‡»é®ç½©å±‚å…³é—­
    if (e.target === aboutOverlay) closeAbout();
};

// æŒ‰ ESC å…³é—­æ‰€æœ‰å¼¹çª—
window.addEventListener('keydown', e => {
    // ... åŸæœ‰ä»£ç  ...
    if (e.code === 'Escape') {
        // ä¾æ¬¡å…³é—­ï¼šå…³äº -> è®¾ç½®/å¸®åŠ© -> é€‰ä¸­
        if (aboutOverlay.classList.contains('show')) {
            closeAbout();
        } else if (els.helpModal.classList.contains('show') || modalSettings.classList.contains('show')) {
            els.helpModal.classList.remove('show');
            els.btnHelp.classList.remove('active');
            modalSettings.classList.remove('show');
            btnSettings.classList.remove('active');
        } else {
            state.selection.clear();
            render();
        }
    }
});

function createNodesFromInput() {
    const text = els.input.value;
    if (!text.trim()) return;

    pushHistory();

    const centerX = (window.innerWidth / 2 - state.view.x) / state.view.scale;
    const centerY = (window.innerHeight / 2 - state.view.y) / state.view.scale;
    const spacingX = 140;
    const spacingY = 80;

    function parsePhrases(input) {
        const regex = /"([^"]*)"|'([^']*)'|â€œ([^â€]*)â€|â€˜([^â€™]*)â€™|([^\s,ï¼Œ\n]+)/g;
        const result = [];
        let match;
        while ((match = regex.exec(input)) !== null) {
            const phrase = match[1] || match[2] || match[3] || match[4] || match[5];
            if (phrase && phrase.trim()) result.push(phrase.trim());
        }
        return result;
    }

    let nodesToCreate = [];

    if (state.settings.preciseLayout) {
        const lines = text.split('\n');
        lines.forEach((line, rowIndex) => {
            const phrases = parsePhrases(line);
            phrases.forEach((phrase, colIndex) => {
                nodesToCreate.push({ text: phrase, row: rowIndex, col: colIndex });
            });
        });

        if (nodesToCreate.length === 0) return;
        const maxRow = Math.max(...nodesToCreate.map(n => n.row));
        const maxCol = Math.max(...nodesToCreate.map(n => n.col));
        const startX = centerX - (maxCol * spacingX) / 2 - 50;
        const startY = centerY - (maxRow * spacingY) / 2 - 20;

        nodesToCreate.forEach(n => {
            state.nodes.push({
                id: uid(), text: n.text,
                x: startX + n.col * spacingX, y: startY + n.row * spacingY,
                w: 0, h: 0, color: 'c-white'
            });
        });
    } else {
        const phrases = parsePhrases(text); 
        const colCount = Math.min(phrases.length, 5);
        const rowCount = Math.ceil(phrases.length / 5);
        const startX = centerX - ((colCount - 1) * spacingX) / 2 - 50;
        const startY = centerY - ((rowCount - 1) * spacingY) / 2 - 20;

        phrases.forEach((str, index) => {
            state.nodes.push({
                id: uid(), text: str,
                x: startX + (index % 5) * spacingX, y: startY + Math.floor(index / 5) * spacingY,
                w: 0, h: 0, color: 'c-white'
            });
        });
    }

    els.input.value = '';
    render();
}


function updateI18n() {
    const texts = TRANSLATIONS[currentLang];

    // 1. ä¿®æ”¹æµè§ˆå™¨æ ‡ç­¾é¡µæ ‡é¢˜
    document.title = texts.page_title;

    // 2. æ›´æ–°æ‰€æœ‰æ–‡æœ¬å†…å®¹ (data-i18n)
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (texts[key]) el.innerText = texts[key];
    });

    // 3. æ›´æ–°æ‰€æœ‰æ‚¬æµ®è¯´æ˜ (data-i18n-title)
    document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title');
        if (texts[key]) el.title = texts[key];
    });

    // 4. æ›´æ–°æ‰€æœ‰å ä½ç¬¦ (data-i18n-placeholder)
    document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
        const key = el.getAttribute('data-i18n-placeholder');
        if (texts[key]) el.placeholder = texts[key];
    });

    // 5. ç‰¹æ®Šå¤„ç†ï¼šè¯­è¨€åˆ‡æ¢æŒ‰é’®æœ¬èº«çš„æ–‡å­—
    document.getElementById('btn-lang').innerText = texts['lang_toggle'];

    // 6. ç‰¹æ®Šå¤„ç†ï¼šæ¸…ç©ºæŒ‰é’®çŠ¶æ€å›å¤
    if (!clearConfirm) {
        document.getElementById('btn-clear').innerText = "ğŸ—‘ï¸";
    }
    // å¯¼å‡ºæŒ‰é’®
    const mainBtn = document.querySelector('#export-container [data-i18n="btn_export"]');
    if (mainBtn) mainBtn.innerText = texts.btn_export;

    localStorage.setItem(LS_LANG_KEY, currentLang);
}

document.getElementById('btn-lang').onclick = (e) => {
    currentLang = currentLang === 'zh' ? 'en' : 'zh';
    updateI18n();
    e.currentTarget.blur();
};

// --- State & Config ---
const state = {
    nodes: [], groups: [], links: [],
    view: { x: window.innerWidth / 2, y: window.innerHeight / 2, scale: 1.2 },
    selection: new Set(),
    clipboard: []
};

// ğŸ†• History System (Undo/Redo)
const MAX_HISTORY = 50;
const history = { undo: [], redo: [] };

function pushHistory() {
    // å°† Set è½¬ä¸º Array å­˜å…¥å¿«ç…§
    const snapshot = JSON.stringify({
        nodes: state.nodes,
        groups: state.groups,
        links: state.links,
        selection: Array.from(state.selection) // âœ¨ ä¿å­˜é€‰ä¸­çŠ¶æ€
    });

    if (history.undo.length > 0 && history.undo[history.undo.length - 1] === snapshot) return;

    history.undo.push(snapshot);
    if (history.undo.length > MAX_HISTORY) history.undo.shift();
    history.redo = [];
}

function undo() {
    if (history.undo.length === 0) return;

    // å­˜å…¥å½“å‰çŠ¶æ€åˆ° redo
    const currentSnapshot = JSON.stringify({
        nodes: state.nodes,
        groups: state.groups,
        links: state.links,
        selection: Array.from(state.selection) // âœ¨
    });
    history.redo.push(currentSnapshot);

    const prev = JSON.parse(history.undo.pop());
    state.nodes = prev.nodes;
    state.groups = prev.groups;
    state.links = prev.links;

    // âœ¨ æ¢å¤é€‰ä¸­çŠ¶æ€
    state.selection = new Set(prev.selection || []);

    render();
}

function redo() {
    if (history.redo.length === 0) return;

    const currentSnapshot = JSON.stringify({
        nodes: state.nodes,
        groups: state.groups,
        links: state.links,
        selection: Array.from(state.selection) // âœ¨
    });
    history.undo.push(currentSnapshot);

    const next = JSON.parse(history.redo.pop());
    state.nodes = next.nodes;
    state.groups = next.groups;
    state.links = next.links;

    // âœ¨ æ¢å¤é€‰ä¸­çŠ¶æ€
    state.selection = new Set(next.selection || []);

    render();
}

const CONFIG = {
    colors: [
        'c-white', 'c-red', 'c-yellow', 'c-green', 'c-blue',
        'c-orange', 'c-purple', 'c-pink', 'c-cyan'
    ]
};
const uid = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

// --- Initialization ---
const LS_KEY = 'cc-canvas-data';
function loadData() {
    const raw = localStorage.getItem(LS_KEY);
    if (raw) {
        try {
            const data = JSON.parse(raw);
            state.nodes = data.nodes || [];
            state.groups = data.groups || [];
            state.links = data.links || [];
        } catch (e) { console.error('Data load failed', e); }
    }
}
function saveData() {
    localStorage.setItem(LS_KEY, JSON.stringify({
        nodes: state.nodes, groups: state.groups, links: state.links
    }));
}
loadData();

// --- Theme Logic ---
const themeBtn = document.getElementById('btn-theme');
const htmlEl = document.documentElement;
let isDark = localStorage.getItem('cc-theme') === 'dark';

// Icons for theme
const ICON_MOON = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>';
const ICON_SUN = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>';

function updateTheme() {
    htmlEl.setAttribute('data-theme', isDark ? 'dark' : 'light');
    themeBtn.innerHTML = isDark ? ICON_SUN : ICON_MOON;
    localStorage.setItem('cc-theme', isDark ? 'dark' : 'light');
}
updateTheme();
themeBtn.onclick = (e) => {
    isDark = !isDark;
    updateTheme();
    e.currentTarget.blur();
};

state.settings = {
    preciseLayout: localStorage.getItem('cc-precise-layout') === 'true',
    hideGrid: localStorage.getItem('cc-hide-grid') === 'true',
    altAsCtrl: localStorage.getItem('cc-alt-as-ctrl') === 'true',
    handDrawn: localStorage.getItem('cc-hand-drawn') === 'true',
    copyMode: localStorage.getItem('cc-copy-mode') === 'true' 
};
const checkCopyMode = document.getElementById('check-copy-mode');
// é½¿è½®æŒ‰é’®ç‚¹å‡»
const btnSettings = document.getElementById('btn-settings');
const modalSettings = document.getElementById('settings-modal');
const checkPrecise = document.getElementById('check-precise');
const checkHideGrid = document.getElementById('check-hide-grid');
const checkAltAsCtrl = document.getElementById('check-alt-as-ctrl');
const checkHandDrawn = document.getElementById('check-hand-drawn');

function applySettings() {
    checkPrecise.checked = state.settings.preciseLayout;
    checkHideGrid.checked = state.settings.hideGrid;
    checkAltAsCtrl.checked = state.settings.altAsCtrl;
    checkHandDrawn.checked = state.settings.handDrawn;
    // æ ¹æ®çŠ¶æ€ç»™ body æ·»åŠ æˆ–ç§»é™¤ç±»
    document.body.classList.toggle('hide-grid', state.settings.hideGrid);
    checkCopyMode.checked = state.settings.copyMode;
}

checkPrecise.onchange = (e) => {
    state.settings.preciseLayout = e.target.checked;
    localStorage.setItem('cc-precise-layout', e.target.checked);
};

checkHideGrid.onchange = (e) => {
    state.settings.hideGrid = e.target.checked;
    localStorage.setItem('cc-hide-grid', e.target.checked);
    document.body.classList.toggle('hide-grid', state.settings.hideGrid);
};

checkAltAsCtrl.onchange = (e) => {
    state.settings.altAsCtrl = e.target.checked;
    localStorage.setItem('cc-alt-as-ctrl', e.target.checked);
};

checkCopyMode.onchange = (e) => {
    state.settings.copyMode = e.target.checked;
    localStorage.setItem('cc-copy-mode', e.target.checked);
};

function isModifier(e) {
    // å¦‚æœå¼€å¯äº†é€‰é¡¹ï¼ŒAlt ä¹Ÿå¯ä»¥ä½œä¸ºè¾…åŠ©é”®
    return e.ctrlKey || e.metaKey || (state.settings.altAsCtrl && e.altKey);
}

btnSettings.onclick = (e) => {
    e.stopPropagation(); // é˜»æ­¢å†’æ³¡ï¼Œé˜²æ­¢è§¦å‘ window.onclick

    const isShowing = modalSettings.classList.contains('show');
    if (isShowing) {
        modalSettings.classList.remove('show');
        btnSettings.classList.remove('active');
    } else {
        // æ‰“å¼€è®¾ç½®æ—¶ï¼Œå…³é—­å¸®åŠ©é¢æ¿ï¼Œé¿å…é‡å 
        els.helpModal.classList.remove('show');
        els.btnHelp.classList.remove('active');

        modalSettings.classList.add('show');
        btnSettings.classList.add('active');
    }
};


// ç‚¹å‡»å¤–éƒ¨å…³é—­è®¾ç½®
window.addEventListener('click', (e) => {
    if (!btnSettings.contains(e.target)) {
        modalSettings.classList.remove('show');
        btnSettings.classList.remove('active');
    }
});

// --- DOM Refs ---
const els = {
    container: document.getElementById('canvas-container'),
    world: document.getElementById('world'),
    nodesLayer: document.getElementById('nodes-layer'),
    groupsLayer: document.getElementById('groups-layer'),
    connectionsLayer: document.getElementById('connections-layer'),
    input: document.getElementById('input-text'),
    selectBox: document.getElementById('selection-box'),
    btnHelp: document.getElementById('btn-help'),
    helpModal: document.getElementById('help-modal'),
    uiLayer: document.getElementById('ui-layer'),
    spotlight: document.getElementById('spotlight-layer'),
};

// --- Render System ---
function render() {
    if (state.nodes.length === 0) {
        document.body.classList.add('is-empty');
    } else {
        document.body.classList.remove('is-empty');
    }
    els.world.style.transform = `translate(${state.view.x}px, ${state.view.y}px) scale(${state.view.scale})`;

    els.connectionsLayer.innerHTML = '';

    const defsContent = `<defs><marker id="arrowhead" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse"><path d="M 0 0 L 8 5 L 0 10" stroke="${getComputedStyle(document.body).getPropertyValue('--link-color').trim()}" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></marker></defs>`;
    els.connectionsLayer.innerHTML = defsContent;

    state.links.forEach(l => {
        const n1 = state.nodes.find(n => n.id === l.sourceId);
        const n2 = state.nodes.find(n => n.id === l.targetId);
        
        // âœ¨ ç¡®ä¿èŠ‚ç‚¹å°ºå¯¸å·²è®¡ç®—ï¼Œå¦åˆ™æ— æ³•è®¡ç®—äº¤ç‚¹
        if (n1 && n2 && n1.w && n1.h && n2.w && n2.h) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            
            // âœ¨âœ¨âœ¨ æ ¸å¿ƒä¿®æ”¹ï¼šè®¡ç®—è¾¹æ¡†äº¤ç‚¹ âœ¨âœ¨âœ¨
            const startPoint = getEdgeIntersection(n2, n1); // ä» n2 æŒ‡å‘ n1 çš„äº¤ç‚¹
            const endPoint = getEdgeIntersection(n1, n2);   // ä» n1 æŒ‡å‘ n2 çš„äº¤ç‚¹

            line.setAttribute('x1', startPoint.x);
            line.setAttribute('y1', startPoint.y);
            line.setAttribute('x2', endPoint.x);
            line.setAttribute('y2', endPoint.y);
            line.classList.add('link');

            if (l.direction === 'target') {
                line.setAttribute('marker-end', 'url(#arrowhead)');
            } else if (l.direction === 'source') {
                // æ³¨æ„ï¼šå½“ç®­å¤´åå‘æ—¶ï¼Œçº¿æ¡çš„èµ·ç‚¹ï¼ˆmarker-startï¼‰æ˜¯ endPoint
                line.setAttribute('marker-start', 'url(#arrowhead)');
            }
            
            els.connectionsLayer.appendChild(line);
        }
    });

    syncDomElements(state.groups, els.groupsLayer, 'group', renderGroup);
    syncDomElements(state.nodes, els.nodesLayer, 'node', renderNode);
    saveData();
}

function syncDomElements(dataArray, parent, className, renderFn) {
    const existing = new Map();
    Array.from(parent.children).forEach(el => existing.set(el.dataset.id, el));
    const activeIds = new Set();
    dataArray.forEach(item => {
        activeIds.add(item.id);
        let el = existing.get(item.id);
        if (!el) { el = document.createElement('div'); el.className = className; el.dataset.id = item.id; parent.appendChild(el); }
        renderFn(el, item);
    });
    existing.forEach((el, id) => { if (!activeIds.has(id)) el.remove(); });
}

function parseMarkdown(text) {
    let escapedText = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

    const lines = escapedText.split('\n');
    const htmlLines = lines.map(line => {
        let processedLine = line;

        processedLine = processedLine.replace(
            /^\[([ xX])\] (.*)/,
            (match, checked, content) => {
                const isChecked = checked.toLowerCase() === 'x';
                // âœ¨ å…³é”®æ”¹åŠ¨ï¼šæ·»åŠ ä¸€ä¸ª .todo-checkbox-wrapper ä½œä¸ºç‚¹å‡»ç›®æ ‡
                return `<span class="todo-item ${isChecked ? 'checked' : ''}" data-checked="${isChecked}">
                          <span class="todo-checkbox-wrapper">
                            <input type="checkbox" ${isChecked ? 'checked' : ''} disabled>
                          </span>
                          <label>${content}</label>
                        </span>`;
            }
        );

        if (!processedLine.includes('class="todo-item"')) {
            processedLine = processedLine.replace(/\*\*(.*?)\*\*|__(.*?)__/g, '<strong>$1$2</strong>');
            processedLine = processedLine.replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)|_(.*?)_/g, '<em>$1$2</em>');
        }
        
        return processedLine;
    });

    return htmlLines.join('<br>');
}

function renderNode(el, node) {
    el.setAttribute('role', 'button');
    el.style.transform = `translate(${node.x}px, ${node.y}px)`;
    
    // å¦‚æœå½“å‰èŠ‚ç‚¹æ­£åœ¨ç¼–è¾‘ï¼Œè·³è¿‡å†…å®¹æ›´æ–°ï¼Œåªæ›´æ–°çŠ¶æ€
    if (el.classList.contains('editing') || el === document.activeElement) {
        const isSelected = state.selection.has(node.id);
        const isEditing = '';
        const classes = ['node', node.color || 'c-white', isEditing ? 'editing' : '', isSelected ? 'selected' : ''].filter(Boolean);
        el.className = classes.join(' ');
        return;
    }

    // --- æ–°çš„æ¸²æŸ“é€»è¾‘ ---

    const isLink = isUrl(node.text);
    const hasMarkdown = /^\s*- \[.\]|\*\*|__|(?<!\*)\*(?!\*)/.test(node.text);

    // æ ¹æ®å†…å®¹å†³å®šæ˜¯å¦å·¦å¯¹é½å’Œå…è®¸å¤šè¡Œ
    // if (node.text.includes('\n') || hasMarkdown) {
    //     el.classList.add('has-multiline');
    // } else {
    //     el.classList.remove('has-multiline');
    // }

    if (isLink) {
        // --- é“¾æ¥èŠ‚ç‚¹çš„æ¸²æŸ“é€»è¾‘ (ä¿æŒä¸å˜) ---
        el.classList.add('is-link');
        el.classList.remove('has-multiline'); // é“¾æ¥å¼ºåˆ¶å•è¡Œ

        let textEl = el.querySelector('.node-text');
        if (!textEl) {
            el.innerHTML = '';
            textEl = document.createElement('div');
            textEl.className = 'node-text';
            el.appendChild(textEl);
        }
        if (textEl.innerText !== node.text) textEl.innerText = node.text;

        let btnEl = el.querySelector('.link-btn');
        if (!btnEl) {
            btnEl = document.createElement('div');
            btnEl.className = 'link-btn';
            btnEl.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>';
            btnEl.onmousedown = (e) => e.stopPropagation();
            btnEl.onclick = (e) => {
                e.stopPropagation();
                let url = node.text.trim();
                if (!url.startsWith('http')) url = 'https://' + url;
                window.open(url, '_blank');
            };
            el.appendChild(btnEl);
        }
    } else {
        // --- æ™®é€šæ–‡æœ¬/Markdown èŠ‚ç‚¹çš„æ¸²æŸ“é€»è¾‘ ---
        el.classList.remove('is-link');
        
        // âœ¨ å…³é”®æ”¹åŠ¨ï¼šä½¿ç”¨ innerHTML å’Œ parseMarkdown
        const newHtml = parseMarkdown(node.text);
        if (el.innerHTML !== newHtml) {
            el.innerHTML = newHtml;
        }
    }

    // --- é€šç”¨æ ·å¼å¤„ç† (ä¿æŒä¸å˜) ---
    const isSelected = state.selection.has(node.id);
    const classes = ['node'];
    if (isLink) classes.push('is-link');
    classes.push(node.color || 'c-white');
    if (isSelected) classes.push('selected');
    // if (el.classList.contains('has-multiline')) classes.push('has-multiline');
    el.className = classes.join(' ');

    if (!node.w || !node.h || el.offsetWidth !== node.w) {
        node.w = el.offsetWidth; node.h = el.offsetHeight;
    }
}

els.nodesLayer.addEventListener('click', e => {
    // âœ¨ æ ¸å¿ƒä¿®æ”¹ï¼šå¯»æ‰¾ .todo-checkbox-wrapper
    const checkboxWrapper = e.target.closest('.todo-checkbox-wrapper');
    if (!checkboxWrapper) {
        return; // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯ wrapper æˆ–å…¶å†…éƒ¨ï¼Œç›´æ¥é€€å‡º
    }

    e.stopPropagation(); // é˜»æ­¢å†’æ³¡ï¼Œè¿™ä»ç„¶éå¸¸é‡è¦

    const nodeEl = checkboxWrapper.closest('.node');
    if (!nodeEl) return;

    const nodeId = nodeEl.dataset.id;
    const node = state.nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    // âœ¨ æ ¸å¿ƒä¿®æ”¹ï¼šé€šè¿‡ wrapper æ‰¾åˆ°å®ƒçš„çˆ¶çº§ todo-item æ¥ç¡®å®šç´¢å¼•
    const todoItem = checkboxWrapper.closest('.todo-item');
    const allTodosInNode = Array.from(nodeEl.querySelectorAll('.todo-item'));
    const clickedIndex = allTodosInNode.indexOf(todoItem);

    if (clickedIndex === -1) return;

    pushHistory();

    const lines = node.text.split('\n');
    let todoCounter = -1;
    const newLines = lines.map(line => {
        if (/^\[([ xX])\]/.test(line.trim())) {
            todoCounter++;
            if (todoCounter === clickedIndex) {
                return line.includes('[ ]') ? line.replace('[ ]', '[x]') : line.replace(/\[[xX]\]/, '[ ]');
            }
        }
        return line;
    });
    
    node.text = newLines.join('\n');
    render();
});


function renderGroup(el, group) {
    el.style.transform = `translate(${group.x}px, ${group.y}px)`;
    el.style.width = `${group.w}px`; el.style.height = `${group.h}px`;
    el.className = `group ${state.selection.has(group.id) ? 'selected' : ''}`;
}
function getNodeCenter(n) { return { x: n.x + (n.w || 0) / 2, y: n.y + (n.h || 0) / 2 }; }

function getEdgeIntersection(sourceNode, targetNode) {
    const sx = sourceNode.x + sourceNode.w / 2;
    const sy = sourceNode.y + sourceNode.h / 2;
    const tx = targetNode.x + targetNode.w / 2;
    const ty = targetNode.y + targetNode.h / 2;
    
    const dx = tx - sx;
    const dy = ty - sy;
    
    const w = targetNode.w / 2;
    const h = targetNode.h / 2;
    
    // è¿™æ˜¯ä¸€ä¸ªéå¸¸é«˜æ•ˆçš„è¿‘ä¼¼ç®—æ³•ï¼Œé¿å…äº†å¤æ‚çš„ä¸‰è§’å‡½æ•°
    const slopeY = Math.abs(dy / dx);
    const slopeX = Math.abs(dx / dy);
    
    let endX, endY;

    if (slopeY < h / w) {
        // äº¤ç‚¹åœ¨å·¦å³ä¸¤ä¾§
        if (dx > 0) {
            endX = tx - w;
            endY = ty - slopeY * w;
        } else {
            endX = tx + w;
            endY = ty + slopeY * w;
        }
    } else {
        // äº¤ç‚¹åœ¨ä¸Šä¸‹ä¸¤ä¾§
        if (dy > 0) {
            endY = ty - h;
            endX = tx - slopeX * h;
        } else {
            endY = ty + h;
            endX = tx + slopeX * h;
        }
    }
    
    return { x: endX, y: endY };
}
// --- èŠ‚æ—¥ Logo é€»è¾‘ ---
function updateSeasonalLogo() {
    const now = new Date();
    const month = now.getMonth() + 1; // 0-11 æ”¹ä¸º 1-12
    const date = now.getDate();
    const logoBox = document.getElementById('ui-logo-box');

    let emoji = "âœ¨"; // é»˜è®¤ï¼šæ˜Ÿæ˜Ÿ

    // 1. 2026 æ˜¥èŠ‚
    if ((month === 2 && date >= 16) || (month === 2 && date <= 23)) {
        emoji = "ğŸ§§";
    }
    // 2. æƒ…äººèŠ‚ (2æœˆ14)
    else if (month === 2 && date === 14) {
        emoji = "ğŸ’–";
    }
    // 3. ä¸‡åœ£èŠ‚ (10æœˆ25 - 10æœˆ31)
    else if (month === 10 && date >= 25) {
        emoji = "ğŸƒ";
    }
    // 4. åœ£è¯èŠ‚ (12æœˆ20 - 12æœˆ26)
    else if (month === 12 && date >= 20 && date <= 31) {
        emoji = "ğŸ„";
    }
    // 5. å…ƒæ—¦ (12æœˆ31 - 1æœˆ1)
    else if ((month === 1 && date <= 3)) {
        emoji = "ğŸ‰";
    }
    logoBox.innerText = emoji;
}

updateSeasonalLogo();
// --- Interactions ---
document.getElementById('btn-add').onclick = createNodesFromInput;

// --- æ–°å¢ï¼šæ‹–æ‹½å¯¼å…¥åŠŸèƒ½ ---

// é˜»æ­¢æµè§ˆå™¨é»˜è®¤æ‰“å¼€æ–‡ä»¶çš„è¡Œä¸º
['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    els.container.addEventListener(eventName, e => {
        e.preventDefault();
        e.stopPropagation();
    }, false);
});

// æ‹–æ‹½è¿›å…¥/ç»è¿‡æ—¶æ˜¾ç¤ºè§†è§‰æç¤º
els.container.addEventListener('dragover', () => {
    els.container.classList.add('drag-over');
});

// æ‹–æ‹½ç¦»å¼€æˆ–ç»“æŸæ—¶éšè—æç¤º
['dragleave', 'drop'].forEach(eventName => {
    els.container.addEventListener(eventName, () => {
        els.container.classList.remove('drag-over');
    });
});

// å¤„ç†æ”¾ä¸‹æ–‡ä»¶
els.container.addEventListener('drop', (e) => {
    const dt = e.dataTransfer;
    const file = dt.files[0];
    processDangoFile(file);
});

els.input.addEventListener('keydown', (e) => {
    // è¯†åˆ« Ctrl + Enter (Windows) æˆ– Cmd + Enter (Mac)
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault(); // é˜»æ­¢è¾“å…¥æ¡†æ¢è¡Œ
        createNodesFromInput();
    }
});
function unpackData(packed) {
    const [version, pNodes, pGroups, pLinks, pSettings] = packed;
    
    // ç”±äº pack æ—¶ç”¨äº†æ•°å­—ç´¢å¼•ï¼Œè§£åŒ…æ—¶æˆ‘ä»¬éœ€è¦é‡æ–°ç”Ÿæˆç¬¦åˆå½“å‰é€»è¾‘çš„ ID
    const shortToLongId = {};
    const genNewId = (shortId) => {
        const newId = uid();
        shortToLongId[shortId] = newId;
        return newId;
    };

    // 1. æ¢å¤èŠ‚ç‚¹
    const nodes = pNodes.map(n => ({
        id: genNewId(n[0]),
        text: n[1],
        x: n[2], y: n[3], w: n[4], h: n[5],
        color: CONFIG.colors[n[6]] || 'c-white'
    }));

    // 2. æ¢å¤ç»„ (å…ˆå ä½ IDï¼Œåç»­æ˜ å°„æˆå‘˜)
    const groups = pGroups.map(g => ({
        id: genNewId(g[0]),
        x: g[1], y: g[2], w: g[3], h: g[4],
        _tempMemberIds: g[5] // ä¸´æ—¶å­˜å‚¨çŸ­ ID
    }));

    // 3. æ˜ å°„ç»„å†…æˆå‘˜ ID
    groups.forEach(g => {
        g.memberIds = g._tempMemberIds.map(sid => shortToLongId[sid]).filter(id => id);
        delete g._tempMemberIds;
    });

    // 4. æ¢å¤è¿çº¿
    const links = pLinks.map(l => ({
        id: uid(),
        sourceId: shortToLongId[l[0]],
        targetId: shortToLongId[l[1]]
    })).filter(l => l.sourceId && l.targetId);

    // 5. æ¢å¤è®¾ç½®
    const settings = pSettings ? {
        preciseLayout: pSettings[0] === 1,
        hideGrid: pSettings[1] === 1,
        handDrawn: pSettings[2] === 1,
        copyMode: pSettings[3] === 1
    } : state.settings;

    return { nodes, groups, links, settings };
}

// æ•°æ®å°åŒ…ï¼šå°†å†—é•¿çš„ state è½¬æ¢ä¸ºæè‡´ç²¾ç®€çš„æ•°ç»„ç»“æ„
function packData() {
    // 1. å»ºç«‹ ID æ˜ å°„è¡¨ï¼Œå°†é•¿ ID æ˜ å°„ä¸ºçŸ­æ•°å­—
    const idMap = {};
    let idCounter = 0;
    const allIds = [
        ...state.nodes.map(n => n.id),
        ...state.groups.map(g => g.id)
    ];
    allIds.forEach(id => idMap[id] = idCounter++);

    // 2. å‹ç¼©èŠ‚ç‚¹: [id, text, x, y, w, h, colorIdx]
    const pNodes = state.nodes.map(n => [
        idMap[n.id],
        n.text,
        Math.round(n.x),
        Math.round(n.y),
        Math.round(n.w),
        Math.round(n.h),
        CONFIG.colors.indexOf(n.color || 'c-white')
    ]);

    // 3. å‹ç¼©ç»„: [id, x, y, w, h, [memberIds]]
    const pGroups = state.groups.map(g => [
        idMap[g.id],
        Math.round(g.x),
        Math.round(g.y),
        Math.round(g.w),
        Math.round(g.h),
        g.memberIds.map(mid => idMap[mid])
    ]);

    // 4. å‹ç¼©è¿çº¿: [sourceId, targetId]
    const pLinks = state.links.map(l => [
        idMap[l.sourceId],
        idMap[l.targetId]
    ]);

    // 5. å‹ç¼©è®¾ç½®: ä»…å­˜å‚¨å…³é”®å¼€å…³ä½ (ä½¿ç”¨ Bitmask æˆ–å°æ•°ç»„)
    const pSettings = [
        state.settings.preciseLayout ? 1 : 0,
        state.settings.hideGrid ? 1 : 0,
        state.settings.handDrawn ? 1 : 0,
        state.settings.copyMode ? 1 : 0
    ];

    // è¿”å›æœ€ç»ˆåµŒå¥—æ•°ç»„ï¼š[ç‰ˆæœ¬å·, èŠ‚ç‚¹, ç»„, è¿çº¿, è®¾ç½®]
    return [1, pNodes, pGroups, pLinks, pSettings];
}

const btnClear = document.getElementById('btn-clear');
let clearConfirm = false;
btnClear.onclick = () => {
    const texts = TRANSLATIONS[currentLang];
    if (!clearConfirm) {
        clearConfirm = true;
        btnClear.innerText = texts['confirm_clear'];
        btnClear.classList.add('btn-danger');
        setTimeout(() => {
            if (clearConfirm) {
                clearConfirm = false;
                btnClear.innerText = "ğŸ—‘ï¸";
                btnClear.classList.remove('btn-danger');
            }
        }, 3000);
    } else {
        // ğŸ’¾ æ•æ‰å¿«ç…§
        const snapshot = { nodes: [...state.nodes], groups: [...state.groups], links: [...state.links] };

        pushHistory();
        state.nodes = []; state.groups = []; state.links = []; state.selection.clear();

        clearConfirm = false;
        btnClear.innerText = "ğŸ—‘ï¸";
        btnClear.classList.remove('btn-danger');
        render();

        // ğŸ å¼¹å‡ºå¸¦â€œæ•‘å‘½ç¨»è‰â€çš„ Toast
        showToast(texts.toast_cleared, snapshot);
    }
};

// Help Toggle
els.btnHelp.onclick = (e) => {
    e.stopPropagation();

    const isShowing = els.helpModal.classList.contains('show');
    if (isShowing) {
        els.helpModal.classList.remove('show');
        els.btnHelp.classList.remove('active');
    } else {
        // æ‰“å¼€å¸®åŠ©æ—¶ï¼Œå…³é—­è®¾ç½®é¢æ¿
        modalSettings.classList.remove('show');
        btnSettings.classList.remove('active');

        els.helpModal.classList.add('show');
        els.btnHelp.classList.add('active');
    }
};

// 3. âœ¨ æ ¸å¿ƒæ”¹è¿›ï¼šç‚¹å‡»é¢æ¿å†…éƒ¨æ—¶ï¼Œä¸è¦å…³é—­é¢æ¿
modalSettings.onclick = (e) => {
    e.stopPropagation();
};

els.helpModal.onclick = (e) => {
    e.stopPropagation();
};

// Close Help when closing UI or clicking outside
els.uiLayer.addEventListener('mouseleave', () => {
    els.helpModal.classList.remove('show');
    els.btnHelp.classList.remove('active');
});
els.helpModal.onclick = (e) => e.stopPropagation();
window.addEventListener('click', (e) => {
    // å…³é—­è®¾ç½®
    if (!btnSettings.contains(e.target) && !modalSettings.contains(e.target)) {
        modalSettings.classList.remove('show');
        btnSettings.classList.remove('active');
    }
    // å…³é—­å¸®åŠ©
    if (!els.btnHelp.contains(e.target) && !els.helpModal.contains(e.target)) {
        els.helpModal.classList.remove('show');
        els.btnHelp.classList.remove('active');
    }
});

let dragStart = null;
let mode = null;
const keys = {};

// Record state BEFORE manipulation starts
let stateBeforeDrag = null;
let isPrepareToClone = false;
let targetAlreadySelectedAtStart = false; // è®°å½•ç‚¹å‡»å‰çš„é€‰ä¸­çŠ¶æ€

els.container.addEventListener('mousedown', e => {
    if (e.target.closest('.todo-checkbox-wrapper')) {
        return;
    }
    if (e.target.isContentEditable) return;
    if (viewAnimationId) {
        cancelAnimationFrame(viewAnimationId);
        viewAnimationId = null;
    }
    if (e.target.closest('.node') && e.detail === 2) return;

    if (e.button === 1 || (e.button === 0 && keys.Space)) {
        mode = 'pan';
        dragStart = { x: e.clientX, y: e.clientY, viewX: state.view.x, viewY: state.view.y };
        document.body.classList.add('mode-pan');
        return;
    }

    if (e.button === 0) {
        const nodeEl = e.target.closest('.node');
        const groupEl = e.target.closest('.group');
        const worldPos = screenToWorld(e.clientX, e.clientY);

        if (nodeEl || groupEl) {
            const id = (nodeEl || groupEl).dataset.id;
            targetIdAtMouseDown = id;
            targetAlreadySelectedAtStart = state.selection.has(id);
            hasMovedDuringDrag = false; // é‡ç½®ç§»åŠ¨æ ‡è®°

            if (isModifier(e)) {
                // Ctrl æ¨¡å¼ï¼šå…ˆç¡®ä¿å®ƒåœ¨é€‰æ‹©é›†é‡Œï¼Œæ–¹ä¾¿æ‹–åŠ¨æˆ–å…‹éš†
                state.selection.add(id);
                isPrepareToClone = true;
                render();
            } else {
                // æ™®é€šæ¨¡å¼ï¼šå¦‚æœç‚¹çš„ä¸æ˜¯å·²é€‰ä¸­çš„ï¼Œæ¸…ç©ºå¹¶é€‰æ‹©å½“å‰
                if (!targetAlreadySelectedAtStart) {
                    state.selection.clear();
                    state.selection.add(id);
                    render();
                }
                isPrepareToClone = false;
            }

            mode = 'move';

            // Snapshot state before dragging starts (for Undo)
            stateBeforeDrag = JSON.stringify({ nodes: state.nodes, groups: state.groups, links: state.links });

            dragStart = { x: worldPos.x, y: worldPos.y, initialPos: getSelectionPositions() };
        } else {
            if (!isModifier(e) && !e.shiftKey) state.selection.clear();
            mode = 'box'; dragStart = { x: e.clientX, y: e.clientY };
            els.selectBox.style.display = 'block';
            updateSelectBox(e.clientX, e.clientY, e.clientX, e.clientY);
            render();
        }
    }
});

window.addEventListener('mousemove', (e) => {
    // å®æ—¶æ›´æ–°å…¨å±€ CSS å˜é‡
    document.documentElement.style.setProperty('--mouse-x', e.clientX + 'px');
    document.documentElement.style.setProperty('--mouse-y', e.clientY + 'px');
});

els.container.addEventListener('mousemove', e => {
    if (!mode) return;
    if (mode === 'pan') {
        state.view.x = dragStart.viewX + (e.clientX - dragStart.x);
        state.view.y = dragStart.viewY + (e.clientY - dragStart.y);
        render();
    } else if (mode === 'move') {
        const worldPos = screenToWorld(e.clientX, e.clientY);
        const dx = worldPos.x - dragStart.x;
        const dy = worldPos.y - dragStart.y;

        // åªè¦ç§»åŠ¨è·ç¦»è¶…è¿‡é˜ˆå€¼ï¼Œå°±æ ‡è®°ä¸ºå·²ç§»åŠ¨
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
            hasMovedDuringDrag = true;

            // è§¦å‘å…‹éš†é€»è¾‘
            if (isPrepareToClone) {
                cloneSelectionInPlace();
                isPrepareToClone = false; // ä¸€æ¬¡æ‹–æ‹½åªå…‹éš†ä¸€æ¬¡
            }
        }

        state.selection.forEach(id => {
            const init = dragStart.initialPos[id];
            if (init) {
                const item = findItem(id);
                if (item) {
                    item.x = init.x + dx; item.y = init.y + dy;
                    if (init.type === 'group') {
                        item.memberIds.forEach(mid => {
                            const member = state.nodes.find(n => n.id === mid);
                            if (member && !dragStart.initialPos[mid]) {
                                const mInit = dragStart.initialPos[`member_${mid}`];
                                if (mInit) { member.x = mInit.x + dx; member.y = mInit.y + dy; }
                            }
                        });
                    }
                }
            }
        });
        render();
    } else if (mode === 'box') {
        updateSelectBox(dragStart.x, dragStart.y, e.clientX, e.clientY);
    }
});

els.container.addEventListener('mouseup', e => {
    if (mode === 'move') {
        // --- ä¿®å¤å¤šæ¬¡å•é€‰çš„å…³é”®é€»è¾‘ ---
        if (!hasMovedDuringDrag && isModifier(e) && targetAlreadySelectedAtStart) {
            // å¦‚æœæ˜¯æŒ‰ä½ Ctrl ç‚¹äº†ä¸€ä¸ªå·²ç»é€‰ä¸­çš„ç‰©ä½“ï¼Œä¸”ä¸­é€”æ²¡ç§»åŠ¨
            // è¯´æ˜ç”¨æˆ·æ˜¯æƒ³â€œå–æ¶ˆé€‰æ‹©â€è¿™ä¸ªç‰©ä½“
            state.selection.delete(targetIdAtMouseDown);
            render();
        }

        if (stateBeforeDrag) {
            const currentState = JSON.stringify({ nodes: state.nodes, groups: state.groups, links: state.links });
            // å¦‚æœå½“å‰çŠ¶æ€å’ŒæŒ‰ä¸‹é¼ æ ‡å‰ä¸ä¸€æ ·ï¼ˆç§»åŠ¨äº†æˆ–å…‹éš†äº†ï¼‰
            if (currentState !== stateBeforeDrag) {
                history.undo.push(stateBeforeDrag); // å°†æŒ‰ä¸‹å‰çš„ä¸€åˆ»å­˜å…¥æ’¤é”€æ ˆ
                if (history.undo.length > MAX_HISTORY) history.undo.shift();
                history.redo = [];
            }
            stateBeforeDrag = null;
        }
    }

    if (mode === 'box') {
        const rect = getStandardRect(dragStart.x, dragStart.y, e.clientX, e.clientY);
        const worldRect = {
            x: (rect.x - state.view.x) / state.view.scale, y: (rect.y - state.view.y) / state.view.scale,
            w: rect.w / state.view.scale, h: rect.h / state.view.scale
        };
        [...state.nodes, ...state.groups].forEach(item => { if (isIntersect(worldRect, item)) state.selection.add(item.id); });
        els.selectBox.style.display = 'none';
        render();
    }
    mode = null;
    dragStart = null;
    isPrepareToClone = false;
    targetIdAtMouseDown = null;
    document.body.classList.remove('mode-pan');
});

els.container.addEventListener('wheel', e => {
    if (viewAnimationId) {
        cancelAnimationFrame(viewAnimationId);
        viewAnimationId = null;
    }
    e.preventDefault();
    if (isModifier(e)) {
        const factor = 1 + ((e.deltaY > 0 ? -1 : 1) * 0.1);
        const worldX = (e.clientX - state.view.x) / state.view.scale;
        const worldY = (e.clientY - state.view.y) / state.view.scale;
        state.view.scale = Math.max(0.1, Math.min(5, state.view.scale * factor));
        state.view.x = e.clientX - worldX * state.view.scale;
        state.view.y = e.clientY - worldY * state.view.scale;
    } else {
        state.view.x -= e.deltaX;
        state.view.y -= e.deltaY;
    }
    render();
}, { passive: false });

// --- ç§»åŠ¨ç«¯è§¦å±æ”¯æŒ (Touch Events) ---

// è¾…åŠ©ï¼šè·å–è§¦æ‘¸ç‚¹çš„åæ ‡ï¼ˆå…¼å®¹å¤šæŒ‡ï¼Œå–ç¬¬ä¸€æŒ‡ï¼‰
function getTouchPos(e) {
    if (e.touches && e.touches.length > 0) {
        return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    return { x: 0, y: 0 };
}

let lastTapTime = 0;
let lastTapTarget = null;
let initialPinchDist = 0;
let initialPinchScale = 1;
let pinchCenter = { x: 0, y: 0 }; // ç¼©æ”¾ä¸­å¿ƒç‚¹

// è¾…åŠ©ï¼šè®¡ç®—ä¸¤æŒ‡è·ç¦»
function getPinchDist(e) {
    return Math.hypot(
        e.touches[0].clientX - e.touches[1].clientX,
        e.touches[0].clientY - e.touches[1].clientY
    );
}

// è¾…åŠ©ï¼šè®¡ç®—ä¸¤æŒ‡ä¸­å¿ƒç‚¹
function getPinchCenter(e) {
    return {
        x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
        y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
}

// 1. é¢æ¿è§¦æ‘¸é€»è¾‘ (ä¿æŒä¸å˜)
els.uiLayer.addEventListener('touchstart', (e) => {
    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
    els.uiLayer.classList.add('mobile-active');
}, { passive: true });


// 2. ç”»å¸ƒå±‚è§¦æ‘¸é€»è¾‘ (æ ¸å¿ƒä¿®æ”¹)
els.container.addEventListener('touchstart', e => {
    // ä¿®å¤é—®é¢˜ 1ï¼šç‚¹å‡»ç”»å¸ƒï¼Œå¼ºåˆ¶å…³é—­ UI é¢æ¿ï¼Œå¹¶è®©è¾“å…¥æ¡†å¤±ç„¦
    els.uiLayer.classList.remove('mobile-active');
    if (document.activeElement && document.activeElement !== document.body) {
        document.activeElement.blur();
    }

    // --- åŒæŒ‡ç¼©æ”¾ (Pinch) æ£€æµ‹ ---
    if (e.touches.length === 2) {
        e.preventDefault(); // é˜»æ­¢æµè§ˆå™¨é»˜è®¤ç¼©æ”¾
        mode = 'pinch';
        initialPinchDist = getPinchDist(e);
        initialPinchScale = state.view.scale;
        // è®°å½•ç¼©æ”¾ä¸­å¿ƒï¼Œç”¨äºä¼˜åŒ–ç¼©æ”¾ä½“éªŒï¼ˆå¯é€‰ï¼Œç®€æ˜“ç‰ˆå¯çœç•¥ï¼‰
        const center = getPinchCenter(e);
        pinchCenter = screenToWorld(center.x, center.y); 
        return;
    }

    // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼ˆé˜²æ­¢æ»šåŠ¨ã€åŸç”Ÿç¼©æ”¾ç­‰ï¼‰ï¼Œé™¤éç‚¹çš„æ˜¯UIå…ƒç´ 
    if (e.target.tagName === 'TEXTAREA' || e.target.closest('.header-btn')) return;
    
    // å¦‚æœä¸åœ¨ç¼–è¾‘çŠ¶æ€ï¼Œé˜»æ­¢é»˜è®¤è¡Œä¸ºä»¥ä¿è¯æ‹–æ‹½æµç•…
    if (!e.target.isContentEditable) {
        e.preventDefault();
    }

    // --- æ¨¡æ‹ŸåŒå‡» (Double Tap) æ£€æµ‹ ---
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTapTime;
    const nodeEl = e.target.closest('.node');
    
    // å¦‚æœä¸¤æ¬¡ç‚¹å‡»é—´éš” < 300ms ä¸”ç›®æ ‡ç›¸åŒï¼Œè§†ä¸ºåŒå‡»
    if (tapLength < 300 && tapLength > 0 && nodeEl && lastTapTarget === nodeEl) {
        handleNodeEdit(nodeEl); // ä¿®å¤é—®é¢˜ 3ï¼šè°ƒç”¨åŒå‡»ç¼–è¾‘
        lastTapTarget = null;
        lastTapTime = 0;
        return;
    }
    lastTapTarget = nodeEl;
    lastTapTime = currentTime;

    // --- å•æŒ‡æ“ä½œé€»è¾‘ ---
    const pos = getTouchPos(e);
    const groupEl = e.target.closest('.group');
    
    if (nodeEl || groupEl) {
        const id = (nodeEl || groupEl).dataset.id;
        
        // å¦‚æœæ²¡é€‰ä¸­ï¼Œé€‰ä¸­å®ƒï¼›å¦‚æœå·²é€‰ä¸­ï¼Œä¿æŒé€‰ä¸­çŠ¶æ€ä»¥ä¾¿æ‹–æ‹½
        if (!state.selection.has(id)) {
            state.selection.clear();
            state.selection.add(id);
            render();
        }

        mode = 'move';
        hasMovedDuringDrag = false;
        // è®°å½•çŠ¶æ€ç”¨äºæ’¤é”€
        stateBeforeDrag = JSON.stringify({ 
            nodes: state.nodes, 
            groups: state.groups, 
            links: state.links, 
            selection: Array.from(state.selection) 
        });
        
        const worldPos = screenToWorld(pos.x, pos.y);
        dragStart = { x: worldPos.x, y: worldPos.y, initialPos: getSelectionPositions() };

    } else {
        // ä¿®å¤é—®é¢˜ 4ï¼šç‚¹å‡»ç©ºç™½å¤„ï¼Œå–æ¶ˆé€‰ä¸­
        state.selection.clear();
        render();

        mode = 'pan';
        dragStart = { x: pos.x, y: pos.y, viewX: state.view.x, viewY: state.view.y };
    }
}, { passive: false });


els.container.addEventListener('touchmove', e => {
    if (!mode) return;
    e.preventDefault();

    // --- ä¿®å¤é—®é¢˜ 2ï¼šåŒæŒ‡ç¼©æ”¾æ‰§è¡Œ ---
    if (mode === 'pinch' && e.touches.length === 2) {
        const currentDist = getPinchDist(e);
        if (currentDist > 0) {
            // è®¡ç®—æ–°çš„ç¼©æ”¾æ¯”ä¾‹
            const scaleFactor = currentDist / initialPinchDist;
            let newScale = initialPinchScale * scaleFactor;
            
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            newScale = Math.max(0.1, Math.min(5, newScale));
            
            // åº”ç”¨ç¼©æ”¾
            state.view.scale = newScale;
            
            // (é«˜çº§) å›´ç»•ä¸­å¿ƒç‚¹ç¼©æ”¾ï¼šç›®å‰ç®€å•å¤„ç†ï¼Œåç»­å¯ä¼˜åŒ– update view x/y
            // ç®€å•ç‰ˆåªæ”¹ scaleï¼Œæ•ˆæœç±»ä¼¼ä¸­å¿ƒç¼©æ”¾ä½†ä¼šåç§»ï¼Œå¯¹äºç§»åŠ¨ç«¯é€šå¸¸å¯æ¥å—
            
            render();
        }
        return;
    }

    // --- å•æŒ‡ç§»åŠ¨é€»è¾‘ ---
    const pos = getTouchPos(e);

    if (mode === 'pan') {
        state.view.x = dragStart.viewX + (pos.x - dragStart.x);
        state.view.y = dragStart.viewY + (pos.y - dragStart.y);
        if (viewAnimationId) { cancelAnimationFrame(viewAnimationId); viewAnimationId = null; }
        render();
    } else if (mode === 'move') {
        const worldPos = screenToWorld(pos.x, pos.y);
        const dx = worldPos.x - dragStart.x;
        const dy = worldPos.y - dragStart.y;
        
        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) hasMovedDuringDrag = true;

        state.selection.forEach(id => {
            const init = dragStart.initialPos[id];
            if (init) {
                const item = findItem(id);
                if (item) {
                    item.x = init.x + dx; 
                    item.y = init.y + dy;
                    if (init.type === 'group') {
                        item.memberIds.forEach(mid => {
                            const member = state.nodes.find(n => n.id === mid);
                            if (member && !dragStart.initialPos[mid]) {
                                const mInit = dragStart.initialPos[`member_${mid}`];
                                if (mInit) { member.x = mInit.x + dx; member.y = mInit.y + dy; }
                            }
                        });
                    }
                }
            }
        });
        render();
    }
}, { passive: false });


els.container.addEventListener('touchend', e => {
    // å¤„ç†ç§»åŠ¨åçš„æ’¤é”€å†å²è®°å½•
    if (mode === 'move' && stateBeforeDrag) {
        const currentState = JSON.stringify({ 
            nodes: state.nodes, 
            groups: state.groups, 
            links: state.links, 
            selection: Array.from(state.selection) 
        });
        if (currentState !== stateBeforeDrag) {
            history.undo.push(stateBeforeDrag);
            if (history.undo.length > MAX_HISTORY) history.undo.shift();
            history.redo = [];
        }
    }
    
    // é‡ç½®æ‰€æœ‰çŠ¶æ€
    stateBeforeDrag = null;
    mode = null;
    dragStart = null;
    initialPinchDist = 0;
});

// --- æå–å‡ºæ¥çš„é€šç”¨ç¼–è¾‘å‡½æ•° ---
function handleNodeEdit(nodeEl) {
    if (!nodeEl) return;
    const node = state.nodes.find(n => n.id === nodeEl.dataset.id);
    if (node) {
        if (mode === 'move' || hasMovedDuringDrag) return;

        pushHistory();

        // âœ¨ å…³é”®æ”¹åŠ¨ï¼šæ— è®ºæ˜¯é“¾æ¥è¿˜æ˜¯ Markdownï¼Œéƒ½ç”¨åŸå§‹æ–‡æœ¬æ›¿æ¢æ¸²æŸ“åçš„ HTML
        nodeEl.innerText = node.text;
        
        // ç§»é™¤æ‰€æœ‰ç‰¹æ®Šæ ·å¼ç±»ï¼Œå›åˆ°æœ€åŸºç¡€çš„ç¼–è¾‘çŠ¶æ€
        nodeEl.classList.remove('is-link', 'has-multiline');
        
        nodeEl.contentEditable = true;
        nodeEl.classList.add('editing');
        nodeEl.focus();

        const range = document.createRange();
        range.selectNodeContents(nodeEl);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);

        const finishEdit = () => {
            nodeEl.contentEditable = false;
            nodeEl.classList.remove('editing');
            
            // âœ¨ æ ¸å¿ƒä¿®å¤ï¼šæ‰‹åŠ¨æ¸…é™¤æµè§ˆå™¨ä¸­çš„æ–‡æœ¬é«˜äº®é€‰åŒº
            const sel = window.getSelection();
            if (sel) {
                sel.removeAllRanges();
            }

            // ä» innerText è·å–æœ€æ–°çš„åŸå§‹æ–‡æœ¬
            const newText = nodeEl.innerText;
            
            // åªæœ‰å½“æ–‡å­—çœŸçš„å˜äº†ï¼Œæ‰æ›´æ–°æ•°æ®å¹¶æ¸²æŸ“
            if (node.text !== newText) {
                node.text = newText;
            }
            render(); 
        };

        nodeEl.onblur = () => {
            nodeEl.onblur = null;
            finishEdit();
        };
        
        nodeEl.onkeydown = (ev) => {
            // âœ¨ å…è®¸åœ¨ç¼–è¾‘æ—¶ä½¿ç”¨ Shift+Enter æ¢è¡Œ
            if (ev.key === 'Enter' && !ev.shiftKey) {
                ev.preventDefault();
                nodeEl.blur(); // è§¦å‘ onblur æ¥ç»“æŸç¼–è¾‘
            }
            ev.stopPropagation();
        };
    }
}

// é¼ æ ‡åŒå‡»ç›‘å¬ä¿æŒä¸å˜ï¼Œåªéœ€è°ƒç”¨ä¸Šé¢çš„å‡½æ•°
els.container.addEventListener('dblclick', e => {
    const nodeEl = e.target.closest('.node');
    handleNodeEdit(nodeEl);
});

window.addEventListener('keydown', e => {
    // å¦‚æœæ­£åœ¨è¾“å…¥ï¼Œè·³è¿‡
    const isEditing = e.target.isContentEditable || e.target.tagName === 'TEXTAREA';
    
    // 1. å¦‚æœæ­£åœ¨ç¼–è¾‘ï¼ŒESC é€€å‡ºç¼–è¾‘è€Œä¸å–æ¶ˆé€‰ä¸­ï¼ŒEnter ç»“æŸç¼–è¾‘
    if (isEditing) {
        if (e.code === 'Escape') {
            e.target.blur(); // è§¦å‘ blur ä¼šä¿å­˜å¹¶é€€å‡º
            e.stopPropagation(); // é˜»æ­¢ ESC è¿›ä¸€æ­¥å½±å“ UI
            return;
        }
        if (e.code === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            e.target.blur();
            return;
        }
        return; // ç¼–è¾‘çŠ¶æ€ä¸‹ä¸è§¦å‘å…¶ä»–å¿«æ·é”®
    }

    keys[e.code] = true;

    // 2. ç”»å¸ƒç¼©æ”¾æ‹¦æˆª (Ctrl + +/-/0)
    if (isModifier(e)) {
        if (e.key === '=' || e.key === '+') {
            e.preventDefault();
            changeZoom(1.2); 
            return;
        }
        if (e.key === '-') {
            e.preventDefault();
            changeZoom(0.8);
            return;
        }
        if (e.key === '0') {
            e.preventDefault();
            resetViewToCenter(true);
            return;
        }
    }

    // 3. å›è½¦ç¼–è¾‘é€‰ä¸­çš„èŠ‚ç‚¹
    if (e.code === 'Enter' && state.selection.size === 1) {
        e.preventDefault();
        const selectedId = Array.from(state.selection)[0];
        const nodeEl = document.querySelector(`.node[data-id="${selectedId}"]`);
        if (nodeEl) handleNodeEdit(nodeEl);
        return;
    }
    
    // 4. ä¼˜åŒ– ESC é€»è¾‘
    if (e.code === 'Escape') {
        // å…³é—­å…³äºé¢æ¿
        if (aboutOverlay.classList.contains('show')) {
            closeAbout();
            return;
        }
        // å…³é—­è®¾ç½®æˆ–å¸®åŠ©
        const isSettingsOpen = modalSettings.classList.contains('show');
        const isHelpOpen = els.helpModal.classList.contains('show');
        if (isSettingsOpen || isHelpOpen) {
            modalSettings.classList.remove('show');
            btnSettings.classList.remove('active');
            els.helpModal.classList.remove('show');
            els.btnHelp.classList.remove('active');
            els.uiLayer.classList.remove('is-active'); // ç§»é™¤å¼ºåˆ¶å±•å¼€ç±»
            return;
        }
        // æœ€åæ‰æ˜¯æ¸…é™¤é€‰ä¸­
        if (state.selection.size > 0) {
            state.selection.clear();
            render();
        }
    }

    if (e.code === 'Space') { e.preventDefault(); document.body.classList.add('mode-space'); }

    // ğŸ†• Undo / Redo Shortcuts
    if (isModifier(e) && e.code === 'KeyZ') {
        e.preventDefault();
        if (e.shiftKey) redo(); else undo();
        return;
    }
    // Redo alternative (Ctrl+Y)
    if (isModifier(e) && e.code === 'KeyY') {
        e.preventDefault(); redo(); return;
    }

    // Actions that change state need pushHistory()
    if (isModifier(e) && e.code === 'KeyG' && !e.shiftKey) { e.preventDefault(); pushHistory(); createGroup(); }
    if (isModifier(e) && e.shiftKey && e.code === 'KeyG') { e.preventDefault(); pushHistory(); dissolveGroup(); }
    if (isModifier(e) && e.code === 'KeyL') { e.preventDefault(); pushHistory(); toggleLink(); }
    if (e.code === 'Delete' || e.code === 'Backspace') { e.preventDefault(); pushHistory(); deleteSelection(); }
    if (e.code === 'Home') { e.preventDefault(); resetViewToCenter(true); }

    if (isModifier(e) && e.code === 'KeyC') { e.preventDefault(); copySelection(); }
    if (isModifier(e) && e.code === 'KeyV') { e.preventDefault(); pushHistory(); pasteClipboard(); }

    // Nudge (also changes state)
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code) && !e.altKey) {
        e.preventDefault();
        // We probably don't want to save history on every pixel nudge, but for correctness:
        // A better approach for nudge might be debouncing history save, but here we keep it simple.
        pushHistory();
        nudgeSelection(e.code);
    }

    if (e.altKey && !e.shiftKey && e.code.startsWith('Digit')) {
        const num = parseInt(e.key);
        if (num >= 1 && num <= 9 && num <= CONFIG.colors.length) {
            e.preventDefault();
            pushHistory();
            colorSelection(CONFIG.colors[num - 1]);
        }
    }

    if (e.ctrlKey && e.code === 'KeyS') { e.preventDefault(); exportJson(); }

    if (e.altKey) {
        pushHistory(); // Alignment changes state
        switch (e.code) {
            case 'KeyA': e.preventDefault(); alignSelection('left'); break;
            case 'KeyD': e.preventDefault(); alignSelection('right'); break;
            case 'KeyW': e.preventDefault(); alignSelection('top'); break;
            case 'KeyS': e.preventDefault(); alignSelection('bottom'); break;
            case 'KeyH': e.preventDefault(); e.shiftKey ? distributeSelection('h') : alignSelection('centerX'); break;
            case 'KeyJ': e.preventDefault(); e.shiftKey ? distributeSelection('v') : alignSelection('centerY'); break;
        }
    }

    if (e.code === 'KeyQ') {
        document.body.classList.add('spotlight-active');
    }
});

window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if (e.code === 'Space') document.body.classList.remove('mode-space');
    if (e.code === 'KeyQ') {
        document.body.classList.remove('spotlight-active');
    }
});

// Helpers
function changeZoom(factor) {
    // é»˜è®¤ä»¥çª—å£ä¸­å¿ƒç¼©æ”¾
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const worldPos = screenToWorld(centerX, centerY);

    const oldScale = state.view.scale;
    state.view.scale = Math.max(0.1, Math.min(5, oldScale * factor));
    
    // è¡¥å¿ä½ç§»ï¼Œå®ç°ä»¥ä¸­å¿ƒç¼©æ”¾
    state.view.x = centerX - worldPos.x * state.view.scale;
    state.view.y = centerY - worldPos.y * state.view.scale;
    
    render();
}

function screenToWorld(sx, sy) { return { x: (sx - state.view.x) / state.view.scale, y: (sy - state.view.y) / state.view.scale }; }
function handleSelection(id, multi) {
    if (!multi) { if (!state.selection.has(id)) { state.selection.clear(); state.selection.add(id); } }
    else { if (state.selection.has(id)) state.selection.delete(id); else state.selection.add(id); }
    render();
}
function getSelectionPositions() {
    const pos = {};
    state.selection.forEach(id => {
        const item = findItem(id);
        if (item) {
            pos[id] = { x: item.x, y: item.y, type: item.text ? 'node' : 'group' };
            if (!item.text && item.memberIds) {
                item.memberIds.forEach(mid => { const m = state.nodes.find(n => n.id === mid); if (m) pos[`member_${mid}`] = { x: m.x, y: m.y }; });
            }
        }
    });
    return pos;
}
function findItem(id) { return state.nodes.find(n => n.id === id) || state.groups.find(g => g.id === id); }
function updateSelectBox(x1, y1, x2, y2) {
    const r = getStandardRect(x1, y1, x2, y2);
    els.selectBox.style.left = r.x + 'px'; els.selectBox.style.top = r.y + 'px';
    els.selectBox.style.width = r.w + 'px'; els.selectBox.style.height = r.h + 'px';
}
function getStandardRect(x1, y1, x2, y2) { return { x: Math.min(x1, x2), y: Math.min(y1, y2), w: Math.abs(x1 - x2), h: Math.abs(y1 - y2) }; }
function isIntersect(r1, r2) {
    const r2w = r2.w || 60; const r2h = r2.h || 40;
    return !(r2.x > r1.x + r1.w || r2.x + r2w < r1.x || r2.y > r1.y + r1.h || r2.y + r2h < r1.y);
}

// --- Logic Actions ---
function copySelection() {
    const selNodes = state.nodes.filter(n => state.selection.has(n.id));
    const selGroups = state.groups.filter(g => state.selection.has(g.id));
    if (selNodes.length > 0 || selGroups.length > 0) {
        state.clipboard = JSON.parse(JSON.stringify({ nodes: selNodes, groups: selGroups }));
    }
}
function pasteClipboard() {
    if (!state.clipboard || (!state.clipboard.nodes.length && !state.clipboard.groups.length)) return;
    state.selection.clear();
    const mapping = {};
    state.clipboard.nodes.forEach(n => {
        const newId = uid(); mapping[n.id] = newId;
        const newNode = { ...n, id: newId, x: n.x + 20, y: n.y + 20 };
        state.nodes.push(newNode); state.selection.add(newId);
    });
    state.clipboard.groups.forEach(g => {
        const newId = uid();
        const newGroup = { ...g, id: newId, x: g.x + 20, y: g.y + 20 };
        newGroup.memberIds = g.memberIds.map(mid => mapping[mid] || mid);
        state.groups.push(newGroup); state.selection.add(newId);
    });
    render();
}
function createGroup() {
    const selectedNodes = state.nodes.filter(n => state.selection.has(n.id));
    if (selectedNodes.length === 0) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    selectedNodes.forEach(n => {
        minX = Math.min(minX, n.x); minY = Math.min(minY, n.y);
        maxX = Math.max(maxX, n.x + (n.w || 0)); maxY = Math.max(maxY, n.y + (n.h || 0));
    });
    const padding = 20;
    const group = { id: uid(), x: minX - padding, y: minY - padding, w: maxX - minX + padding * 2, h: maxY - minY + padding * 2, memberIds: selectedNodes.map(n => n.id) };
    state.groups.push(group); state.selection.clear(); state.selection.add(group.id); render();
}
function dissolveGroup() {
    const toRemove = [];
    state.selection.forEach(id => { const idx = state.groups.findIndex(g => g.id === id); if (idx !== -1) toRemove.push(idx); });
    toRemove.sort((a, b) => b - a).forEach(idx => state.groups.splice(idx, 1));
    if (toRemove.length > 0) { state.selection.clear(); render(); }
}
function toggleLink() {
    const sel = Array.from(state.selection);
    const nodes = sel.map(id => state.nodes.find(n => n.id === id)).filter(n => n);
    if (nodes.length !== 2) return;
    
    // ä¸ºäº†é€»è¾‘ç¨³å®šï¼Œæˆ‘ä»¬ä¸ä¾èµ–é€‰æ‹©é¡ºåºï¼Œè€Œæ˜¯å›ºå®šä¸€ä¸ªä¸º sourceï¼Œä¸€ä¸ªä¸º target
    const [n1, n2] = nodes;

    const existingLinkIndex = state.links.findIndex(l => 
        (l.sourceId === n1.id && l.targetId === n2.id) || 
        (l.sourceId === n2.id && l.targetId === n1.id)
    );

    if (existingLinkIndex !== -1) {
        // --- é“¾æ¥å·²å­˜åœ¨ï¼Œè¿›å…¥çŠ¶æ€å¾ªç¯ ---
        const link = state.links[existingLinkIndex];
        
        // ç¡®ä¿ sourceId å’Œ targetId ä¸æˆ‘ä»¬å½“å‰è·å–çš„ n1, n2 ä¸€è‡´ï¼Œæ–¹ä¾¿åˆ¤æ–­
        const isReversed = link.sourceId === n2.id;

        switch (link.direction) {
            case 'none':
                // çŠ¶æ€ 1 -> 2: æ— æ–¹å‘ -> æŒ‡å‘ n2
                link.direction = isReversed ? 'source' : 'target';
                break;
            
            case 'target':
                // çŠ¶æ€ 2 -> 3: æŒ‡å‘ target -> æŒ‡å‘ source (æˆ–åå‘)
                link.direction = isReversed ? 'none' : 'source'; // è¿™é‡Œé€»è¾‘ç¨å¾®å¤æ‚
                if(isReversed) link.direction = 'none'; // å¦‚æœåäº†ï¼Œç›´æ¥å›åˆ° none
                else link.direction = 'source';
                break;
            
            case 'source':
                // çŠ¶æ€ 3 -> 4: æŒ‡å‘ source -> åˆ é™¤
                state.links.splice(existingLinkIndex, 1);
                break;

            default: // å…¼å®¹æ—§æ•°æ®
                 link.direction = 'target';
                 break;
        }

    } else {
        // --- é“¾æ¥ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ (çŠ¶æ€ 0 -> 1) ---
        state.links.push({ 
            id: uid(), 
            sourceId: n1.id, 
            targetId: n2.id,
            direction: 'none' // åˆå§‹çŠ¶æ€ï¼šæ— æ–¹å‘
        });
    }
    
    render();
}
function deleteSelection() {
    const sel = state.selection;
    state.nodes = state.nodes.filter(n => !sel.has(n.id));
    state.groups = state.groups.filter(g => !sel.has(g.id));
    state.links = state.links.filter(l => !sel.has(l.sourceId) && !sel.has(l.targetId));
    state.groups.forEach(g => { g.memberIds = g.memberIds.filter(mid => state.nodes.find(n => n.id === mid)); });
    state.selection.clear(); render();
}
function nudgeSelection(key) {
    const step = 10; let dx = 0, dy = 0;
    if (key === 'ArrowUp') dy = -step; if (key === 'ArrowDown') dy = step;
    if (key === 'ArrowLeft') dx = -step; if (key === 'ArrowRight') dx = step;
    state.selection.forEach(id => {
        const item = findItem(id);
        if (item) setItemPos(item, item.x + dx, item.y + dy);
    });
    render();
}
function colorSelection(colorClass) { state.nodes.forEach(n => { if (state.selection.has(n.id)) n.color = colorClass; }); render(); }
function setItemPos(item, newX, newY) {
    const dx = newX - item.x; const dy = newY - item.y;
    item.x = newX; item.y = newY;
    if (!item.text && item.memberIds) {
        item.memberIds.forEach(mid => { const m = state.nodes.find(n => n.id === mid); if (m) { m.x += dx; m.y += dy; } });
    }
}
function alignSelection(type) {
    const items = [...state.selection].map(id => findItem(id)).filter(i => i);
    if (items.length < 2) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    items.forEach(i => {
        minX = Math.min(minX, i.x); minY = Math.min(minY, i.y);
        maxX = Math.max(maxX, i.x + (i.w || 0)); maxY = Math.max(maxY, i.y + (i.h || 0));
    });
    const centerX = minX + (maxX - minX) / 2; const centerY = minY + (maxY - minY) / 2;
    items.forEach(i => {
        const w = i.w || 0; const h = i.h || 0; let nx = i.x, ny = i.y;
        if (type === 'left') nx = minX; else if (type === 'right') nx = maxX - w; else if (type === 'centerX') nx = centerX - w / 2;
        else if (type === 'top') ny = minY; else if (type === 'bottom') ny = maxY - h; else if (type === 'centerY') ny = centerY - h / 2;
        setItemPos(i, nx, ny);
    });
    render();
}
function distributeSelection(axis) {
    const items = [...state.selection].map(id => findItem(id)).filter(i => i);
    if (items.length < 3) return;
    if (axis === 'h') {
        items.sort((a, b) => a.x - b.x);
        const start = items[0].x; const end = items[items.length - 1].x + (items[items.length - 1].w || 0);
        const totalW = items.reduce((s, i) => s + (i.w || 0), 0);
        const gap = (end - start - totalW) / (items.length - 1);
        let cx = start; items.forEach(i => { setItemPos(i, cx, i.y); cx += (i.w || 0) + gap; });
    } else {
        items.sort((a, b) => a.y - b.y);
        const start = items[0].y; const end = items[items.length - 1].y + (items[items.length - 1].h || 0);
        const totalH = items.reduce((s, i) => s + (i.h || 0), 0);
        const gap = (end - start - totalH) / (items.length - 1);
        let cy = start; items.forEach(i => { setItemPos(i, i.x, cy); cy += (i.h || 0) + gap; });
    }
    render();
}

function getTimestamp() {
    const now = new Date(); const pad = (n) => String(n).padStart(2, '0');
    return `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}`;
}
function exportJson() {
    const data = JSON.stringify({ nodes: state.nodes, groups: state.groups, links: state.links }, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob); const a = document.createElement('a');
    a.href = url; a.download = `dango-canvas_${getTimestamp()}.dango`;  a.click(); URL.revokeObjectURL(url);
}

function cloneSelectionInPlace() {
    // 1. ğŸ”´ ç§»é™¤è¿™é‡Œçš„ pushHistory()ï¼Œäº¤ç»™ mouseup ç»Ÿä¸€å¤„ç†

    const mapping = {};
    const newNodes = [];
    const newGroups = [];
    const newSelection = new Set();

    // 2. å¤åˆ¶èŠ‚ç‚¹
    state.nodes.forEach(n => {
        if (state.selection.has(n.id)) {
            const newId = uid();
            mapping[n.id] = newId;
            // åˆ›å»ºå‰¯æœ¬
            const newNode = { ...n, id: newId };
            newNodes.push(newNode);
            newSelection.add(newId); // æ–°èŠ‚ç‚¹å°†è¿›å…¥é€‰æ‹©é›†

            // é‡è¦ï¼šå°†æ–°èŠ‚ç‚¹çš„åˆå§‹ä½ç½®åŒæ­¥åˆ° dragStartï¼Œä»¥ä¾¿åç»­ mousemove è®¡ç®—
            if (dragStart && dragStart.initialPos[n.id]) {
                dragStart.initialPos[newId] = { ...dragStart.initialPos[n.id] };
            }
        }
    });

    // 3. å¤åˆ¶ç»„
    state.groups.forEach(g => {
        if (state.selection.has(g.id)) {
            const newId = uid();
            const newGroup = { ...g, id: newId };
            newGroup.memberIds = g.memberIds.map(mid => mapping[mid] || mid);
            newGroups.push(newGroup);
            newSelection.add(newId);

            if (dragStart && dragStart.initialPos[g.id]) {
                dragStart.initialPos[newId] = { ...dragStart.initialPos[g.id] };
            }
        }
    });

    // 4. æ›´æ–°ç”»å¸ƒçŠ¶æ€
    state.nodes.push(...newNodes);
    state.groups.push(...newGroups);

    // 5. âœ¨ å…³é”®ï¼šåˆ‡æ¢é€‰æ‹©é›†
    // åŸæ¥çš„èŠ‚ç‚¹ï¼ˆå¸¦çº¿çš„ï¼‰ä¼šç•™åœ¨åŸåœ°ï¼Œé¼ æ ‡ç°åœ¨æ‹–æ‹½çš„æ˜¯æ–°ç”Ÿæˆçš„å‰¯æœ¬
    state.selection = newSelection;
}

// --- æ–°å¢ï¼šé€šç”¨æ–‡ä»¶å¤„ç†é€»è¾‘ ---
function processDangoFile(file) {
    if (!file) return;
    
    // æ£€æŸ¥æ–‡ä»¶åç¼€ï¼ˆéå¼ºåˆ¶ï¼Œä½†æ›´å®‰å…¨ï¼‰
    if (!file.name.endsWith('.dango') && !file.name.endsWith('.json')) {
        showToast(TRANSLATIONS[currentLang].alert_file_err);
        return;
    }

    const reader = new FileReader();
    reader.onload = (ev) => {
        try {
            const data = JSON.parse(ev.target.result);
            
            // å¤‡ä»½å½“å‰æ•°æ®ä»¥ä¾›æ’¤é”€
            let oldSnapshot = null;
            if (state.nodes.length > 0) {
                oldSnapshot = { nodes: [...state.nodes], groups: [...state.groups], links: [...state.links] };
            }
            
            pushHistory();
            
            // åŠ è½½æ–°æ•°æ®
            state.nodes = data.nodes || [];
            state.groups = data.groups || [];
            state.links = data.links || [];
            state.selection.clear();
            
            render();
            // ğŸ æˆåŠŸæç¤º
            showToast(TRANSLATIONS[currentLang].toast_import_success, oldSnapshot);
        }
        catch (err) {
            console.error(err);
            showToast(TRANSLATIONS[currentLang].alert_file_err);
        }
    };
    reader.readAsText(file);
}

// document.getElementById('btn-export').onclick = exportJson;
document.getElementById('file-input').onchange = (e) => {
    processDangoFile(e.target.files[0]);
    e.target.value = ''; // æ¸…ç©º input æ–¹ä¾¿é‡å¤å¯¼å…¥åŒä¸€æ–‡ä»¶
};


document.getElementById('btn-import-main').onclick = () => {
    document.getElementById('file-input').click();
};


// è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆ SVG å­—ç¬¦ä¸² (æå–è‡ªä¹‹å‰çš„é€»è¾‘)
function getSvgString() {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const elements = [...state.nodes, ...state.groups];
    if (elements.length === 0) return null;

    elements.forEach(el => {
        minX = Math.min(minX, el.x); minY = Math.min(minY, el.y);
        maxX = Math.max(maxX, el.x + (el.w || 100)); maxY = Math.max(maxY, el.y + (el.h || 40));
    });

    const padding = 80;
    const width = maxX - minX + padding * 2;
    const height = maxY - minY + padding * 2;
    const offsetX = -minX + padding;
    const offsetY = -minY + padding;

    const bodyStyle = getComputedStyle(document.body);
    const bgColor = bodyStyle.backgroundColor;
    const dotColor = bodyStyle.getPropertyValue('--dot-color').trim() || '#cbd5e1';
    const groupBorderColor = bodyStyle.getPropertyValue('--group-border').trim();
    const groupBgColor = bodyStyle.getPropertyValue('--group-bg').trim();
    const linkColor = bodyStyle.getPropertyValue('--link-color').trim();
    const isHandDrawn = state.settings.handDrawn;
    const fontFamily = isHandDrawn ? "'Architects Daughter', 'LXGW WenKai Mono TC', cursive" : "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";
    const nodePaddingX = 20;

    let defsContent = `<style>@import url('https://fonts.googleapis.com/css2?family=Architects+Daughter&amp;family=LXGW+WenKai+Mono+TC&amp;display=swap'); .node-text { font-family: ${fontFamily}; font-size: 14px; font-weight: 500; }</style><pattern id="grid" width="24" height="24" patternUnits="userSpaceOnUse"><circle cx="1.5" cy="1.5" r="1.5" fill="${dotColor}" /></pattern>`;
    state.nodes.forEach(n => {
        defsContent += `<clipPath id="clip-${n.id}"><rect x="${n.x + offsetX + nodePaddingX}" y="${n.y + offsetY}" width="${n.w - nodePaddingX * 2}" height="${n.h}" /></clipPath>`;
    });

    let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}"><defs>${defsContent}</defs><rect width="100%" height="100%" fill="${bgColor}"/>`;
    if (!state.settings.hideGrid) svgContent += `<rect width="100%" height="100%" fill="url(#grid)"/>`;

    state.groups.forEach(g => {
        svgContent += `<rect x="${g.x + offsetX}" y="${g.y + offsetY}" width="${g.w}" height="${g.h}" rx="20" ry="20" fill="${groupBgColor}" stroke="${groupBorderColor}" stroke-width="2" stroke-dasharray="5,5" />`;
    });

    state.links.forEach(l => {
        const n1 = state.nodes.find(n => n.id === l.sourceId), n2 = state.nodes.find(n => n.id === l.targetId);
        if (n1 && n2) {
            const c1 = { x: n1.x + (n1.w || 0) / 2 + offsetX, y: n1.y + (n1.h || 0) / 2 + offsetY }, c2 = { x: n2.x + (n2.w || 0) / 2 + offsetX, y: n2.y + (n2.h || 0) / 2 + offsetY };
            svgContent += `<line x1="${c1.x}" y1="${c1.y}" x2="${c2.x}" y2="${c2.y}" stroke="${linkColor}" stroke-width="2" opacity="0.5" />`;
        }
    });

    state.nodes.forEach(n => {
        const el = document.querySelector(`.node[data-id="${n.id}"]`);
        if (!el) return;
        const style = getComputedStyle(el), nodeBg = style.backgroundColor, nodeStroke = style.borderColor, nodeTextColor = style.color, isLink = isUrl(n.text), rx = isHandDrawn ? 18 : 12;
        let textX = isLink ? n.x + offsetX + nodePaddingX : n.x + n.w / 2 + offsetX;
        let textAnchor = isLink ? "start" : "middle";

        let nodeMarkup = `<rect x="${n.x + offsetX}" y="${n.y + offsetY}" width="${n.w}" height="${n.h}" rx="${rx}" ry="${rx}" fill="${nodeBg}" stroke="${nodeStroke}" stroke-width="${isLink ? 1.5 : 1}" /><text x="${textX}" y="${n.y + n.h / 2 + offsetY}" class="node-text" clip-path="url(#clip-${n.id})" dominant-baseline="central" text-anchor="${textAnchor}" fill="${nodeTextColor}">${escapeHtml(n.text)}</text>`;
        
        if (isLink) {
            let fullUrl = n.text.trim(); if (!fullUrl.startsWith('http')) fullUrl = 'https://' + fullUrl;
            const lineY = n.y + n.h / 2 + offsetY + 8, lineX1 = n.x + offsetX + nodePaddingX, lineX2 = n.x + offsetX + n.w - nodePaddingX;
            nodeMarkup = `<a xlink:href="${escapeHtml(fullUrl)}" target="_blank"><g>${nodeMarkup}<line x1="${lineX1}" y1="${lineY}" x2="${lineX2}" y2="${lineY}" stroke="${nodeTextColor}" stroke-width="1" opacity="0.4" /></g></a>`;
        }
        svgContent += nodeMarkup;
    });

    return { html: svgContent + `</svg>`, width, height };
}

// æ ¸å¿ƒåŠŸèƒ½ï¼šç»Ÿä¸€å¯¼å‡ºå›¾ç‰‡å‡½æ•°
async function downloadImage() {
    const svgData = getSvgString();
    if (!svgData) return;

    // 1. åˆ›å»º Canvas
    const canvas = document.createElement('canvas');
    const scale = 3; // å¼ºåˆ¶ 3x é«˜æ¸…
    canvas.width = svgData.width * scale;
    canvas.height = svgData.height * scale;
    const ctx = canvas.getContext('2d');

    const img = new Image();
    const svgBlob = new Blob([svgData.html], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    img.onload = async () => {
        // ç»˜åˆ¶é«˜æ¸…å›¾
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.scale(scale, scale);
        ctx.drawImage(img, 0, 0);
        
        if (state.settings.copyMode) {
            // æ¨¡å¼ A: å¤åˆ¶åˆ°å‰ªè´´æ¿
            canvas.toBlob(async (blob) => {
                try {
                    const item = new ClipboardItem({ "image/png": blob });
                    await navigator.clipboard.write([item]);
                    showToast(TRANSLATIONS[currentLang].toast_copy_success);
                } catch (err) {
                    console.error(err);
                    showToast(TRANSLATIONS[currentLang].toast_copy_fail);
                }
                URL.revokeObjectURL(url);
            }, 'image/png');
        } else {
            // æ¨¡å¼ B: ä¸‹è½½æ–‡ä»¶
            canvas.toBlob((blob) => {
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `dango_${getTimestamp()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png');
        }
    };
    img.src = url;
}

// è¾…åŠ©ï¼šè½¬ä¹‰ HTML ç‰¹æ®Šå­—ç¬¦é˜²æ­¢ SVG æŠ¥é”™
function escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}

// è¾…åŠ©ï¼šä¸‹è½½å‡½æ•°
function downloadBlob(content, filename, contentType) {
    const blob = new Blob([content], { type: contentType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename; a.click();
    URL.revokeObjectURL(url);
}


const actionStack = document.getElementById('action-stack');
const btnExportMain = document.getElementById('btn-export-main');
let exportResetTimer = null;

// é¢æ¿é‡ç½®å‡½æ•°
function resetActionStack() {
    actionStack.classList.remove('is-exporting');
    clearTimeout(exportResetTimer);
}

// ç‚¹å‡»â€œå¯¼å‡ºâ€ï¼šç¿»è½¬
btnExportMain.onclick = (e) => {
    e.stopPropagation();
    actionStack.classList.add('is-exporting');

    // 5ç§’è‡ªåŠ¨é‡ç½®ï¼ˆç”¨æˆ·æ— æ“ä½œæ—¶è‡ªåŠ¨é€€å›ï¼‰
    clearTimeout(exportResetTimer);
    exportResetTimer = setTimeout(resetActionStack, 5000);
};

// å…·ä½“çš„é€‰é¡¹é€»è¾‘
document.getElementById('opt-json').onclick = (e) => {
    e.stopPropagation();
    exportJson();
    resetActionStack(); // ç‚¹å‡»å³æ¶ˆå¤±
};

document.getElementById('opt-png').onclick = (e) => {
    e.stopPropagation();
    downloadImage(); // é»˜è®¤ PNG
    resetActionStack();
};

// document.getElementById('opt-svg').onclick = (e) => {
//     e.stopPropagation();
//     downloadImage('svg'); // é€‰ä¸­çš„ SVG
//     resetActionStack();
// };

document.getElementById('opt-link').onclick = (e) => {
    e.stopPropagation();
    createShareLink();
    resetActionStack(); // ä½ çš„ç›´è§‰ï¼šLINK ç‚¹å‡»åä¹Ÿç«‹å³æ¶ˆå¤±
};

// è¡¥å……ï¼šç‚¹å‡»é¡µé¢å…¶ä»–åœ°æ–¹ä¹Ÿé‡ç½®é¢æ¿
window.addEventListener('click', () => {
    if (actionStack.classList.contains('is-exporting')) {
        resetActionStack();
    }
});

function createShareLink() {
    const packed = packData();
    // ç°åœ¨å‹ç¼©çš„æ˜¯æè‡´ç²¾ç®€çš„æ•°ç»„ï¼ŒJSON å­—ç¬¦ä¸²é•¿åº¦ä¼šç¼©å‡ 60%-80%
    const compressed = LZString.compressToEncodedURIComponent(JSON.stringify(packed));
    
    const baseUrl = window.location.href.split('#')[0];
    const url = baseUrl + '#' + compressed;

    navigator.clipboard.writeText(url).then(() => {
        showToast(currentLang === 'zh' ? "é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ âœ¨" : "Link copied to clipboard âœ¨");
    });
}

state.settings.handDrawn = localStorage.getItem('cc-hand-drawn') === 'true';

let fontsLoaded = false;

// 2. åŠ¨æ€åŠ è½½å­—ä½“å‡½æ•°
function loadHandDrawnFonts() {
    if (fontsLoaded || document.getElementById('hand-drawn-fonts')) return;

    const link = document.createElement('link');
    link.id = 'hand-drawn-fonts'; // å¢åŠ  ID é˜²æ­¢é‡å¤æ’å…¥
    link.rel = 'stylesheet';
    // ğŸ’¡ ä¼˜åŒ–ï¼šåœ¨ URL åé¢å¢åŠ  &display=block å‡å°‘é—ªçƒï¼ˆè™½ç„¶ swap ä¹Ÿä¸é”™ï¼Œä½† block åœ¨æ‰“å­—æ—¶æ›´ç¨³å®šï¼‰
    link.href = 'https://fonts.googleapis.com/css2?family=Architects+Daughter&family=LXGW+WenKai+Mono+TC&display=block';

    document.head.appendChild(link);
    fontsLoaded = true;
}


// 3. ç»‘å®šå¼€å…³
checkHandDrawn.onchange = (e) => {
    state.settings.handDrawn = e.target.checked;
    localStorage.setItem('cc-hand-drawn', e.target.checked);
    applyHandDrawnStyle();
};

function applyHandDrawnStyle() {
    if (state.settings.handDrawn) {
        loadHandDrawnFonts();
        document.body.classList.add('hand-drawn-style');
    } else {
        document.body.classList.remove('hand-drawn-style');
    }
}

function loadFromUrl() {
    const hash = window.location.hash.substring(1);
    if (!hash) return false;

    try {
        const decompressed = LZString.decompressFromEncodedURIComponent(hash);
        if (!decompressed) return false;
        
        const dataRaw = JSON.parse(decompressed);
        // åˆ¤æ–­æ˜¯å¦æ˜¯æ–°ç‰ˆæ•°ç»„å°åŒ…ç»“æ„
        const data = Array.isArray(dataRaw) ? unpackData(dataRaw) : dataRaw;

        // ... åç»­åŠ è½½é€»è¾‘ä¸å˜ (pushHistory, render, showToast) ...
        // ğŸ’¾ æ•æ‰æ—§æ•°æ®å¿«ç…§
        let oldSnapshot = null;
        if (state.nodes.length > 0) {
            oldSnapshot = { nodes: [...state.nodes], groups: [...state.groups], links: [...state.links] };
            pushHistory();
        }

        state.nodes = data.nodes;
        state.groups = data.groups;
        state.links = data.links;
        if (data.settings) state.settings = { ...state.settings, ...data.settings };

        render();
        applySettings();
        applyHandDrawnStyle();

        showToast(TRANSLATIONS[currentLang].toast_imported, oldSnapshot);
        window.history.replaceState(null, null, window.location.pathname);
        return true;
    } catch (e) {
        console.error("Import failed:", e);
        return false;
    }
}

// åœ¨é¡µé¢åˆå§‹åŒ–ï¼ˆæ¯”å¦‚ window.onload æˆ– main.js åº•éƒ¨ï¼‰è°ƒç”¨
if (!loadFromUrl()) {
    loadData(); // å¦‚æœ URL æ²¡æ•°æ®ï¼Œå†å°è¯•ä»æœ¬åœ°å­˜å‚¨åŠ è½½
}

function showToast(message, safetySnapshot = null) {
    const texts = TRANSLATIONS[currentLang];
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = 'toast';

    // åŸºç¡€æ–‡æœ¬
    const textNode = document.createElement('span');
    textNode.innerText = message;
    toast.appendChild(textNode);

    // å¦‚æœæä¾›äº†å¿«ç…§ï¼Œæ·»åŠ â€œæ•‘å‘½ç¨»è‰â€æŒ‰é’®
    if (safetySnapshot) {
        const actions = document.createElement('div');
        actions.className = 'toast-actions';

        // 1. æ’¤é”€æŒ‰é’®
        const btnUndo = document.createElement('button');
        btnUndo.className = 'btn-toast';
        btnUndo.innerText = texts.toast_undo;
        btnUndo.onclick = () => { undo(); toast.remove(); };

        // 2. å¯¼å‡ºå¤‡ä»½æŒ‰é’®
        const btnExport = document.createElement('button');
        btnExport.className = 'btn-toast';
        btnExport.innerText = texts.toast_export_prev;
        btnExport.onclick = () => {
            const data = JSON.stringify(safetySnapshot, null, 2);
            downloadBlob(data, `safety-backup_${getTimestamp()}.dango`, 'application/json');
            toast.remove();
        };

        actions.appendChild(btnUndo);
        actions.appendChild(btnExport);
        toast.appendChild(actions);
    }

    container.appendChild(toast);
    setTimeout(() => toast.classList.add('show'), 10);

    // æœ‰äº¤äº’çš„ Toast åœç•™æ—¶é—´ç¨é•¿ (6ç§’)ï¼Œçº¯æ–‡æœ¬ 3ç§’
    const delay = safetySnapshot ? 6000 : 3000;
    setTimeout(() => {
        if (toast.parentNode) {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 400);
        }
    }, delay);
}

function resetViewToCenter(animated = true) {
    let targetX, targetY, targetScale = 1.2;
    targetX = window.innerWidth / 2;
    targetY = window.innerHeight / 2;

    if (animated) {
        animateView(targetX, targetY, targetScale);
    } else {
        state.view.x = targetX;
        state.view.y = targetY;
        state.view.scale = targetScale;
        render();
    }
}

// --- è§†å›¾åŠ¨ç”»ç³»ç»Ÿ ---
let viewAnimationId = null;

function animateView(targetX, targetY, targetScale, duration = 400) {
    // å¦‚æœä¹‹å‰æœ‰åŠ¨ç”»åœ¨è·‘ï¼Œå…ˆåœæ‰
    if (viewAnimationId) cancelAnimationFrame(viewAnimationId);

    const startX = state.view.x;
    const startY = state.view.y;
    const startScale = state.view.scale;
    const startTime = performance.now();

    function step(now) {
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        if (progress < 1) {
            // åŠ¨ç”»è¿è¡Œä¸­
            const ease = 1 - Math.pow(2, -10 * progress);
            state.view.x = startX + (targetX - startX) * ease;
            state.view.y = startY + (targetY - startY) * ease;
            state.view.scale = startScale + (targetScale - startScale) * ease;
            render();
            viewAnimationId = requestAnimationFrame(step);
        } else {
            // âœ¨ æœ€åä¸€å¸§ï¼šå¼ºåˆ¶ç²¾å‡†èµ‹å€¼ï¼Œæ¶ˆé™¤ 0.1% çš„æ•°å­¦è¯¯å·®
            state.view.x = targetX;
            state.view.y = targetY;
            state.view.scale = targetScale;
            render();
            viewAnimationId = null; // åŠ¨ç”»å½»åº•ç»“æŸ
        }
    }


    viewAnimationId = requestAnimationFrame(step);
}
// åˆå§‹åº”ç”¨
applyHandDrawnStyle();
applySettings();
render();
updateI18n();