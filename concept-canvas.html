<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è½»é‡çº§æ¦‚å¿µç”»å¸ƒ (Concept Canvas) - v3</title>
    <style>
        /* --- å˜é‡å®šä¹‰ï¼šæ”¯æŒæ—¥/å¤œæ¨¡å¼ --- */
        :root {
            /* ğŸŒ Light Mode (é»˜è®¤) */
            --bg-color: #f8f9fa;
            --dot-color: #cbd5e1;

            --ui-bg: rgba(255, 255, 255, 0.85);
            --ui-border: rgba(255, 255, 255, 0.6);
            --ui-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
            --ui-text: #334155;

            --node-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            --node-shadow-hover: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);

            --select-color: #6366f1;
            --group-bg: rgba(99, 102, 241, 0.05);
            --group-border: #a5b4fc;
            --link-color: #94a3b8;

            /* èŠ‚ç‚¹é…è‰² (æµ…è‰²æ¨¡å¼) */
            --c-white-bg: #ffffff;
            --c-white-border: #e2e8f0;
            --c-white-text: #1e293b;
            --c-red-bg: #fee2e2;
            --c-red-border: #fecaca;
            --c-red-text: #991b1b;
            --c-yellow-bg: #fef3c7;
            --c-yellow-border: #fde68a;
            --c-yellow-text: #92400e;
            --c-green-bg: #d1fae5;
            --c-green-border: #a7f3d0;
            --c-green-text: #065f46;
            --c-blue-bg: #e0e7ff;
            --c-blue-border: #c7d2fe;
            --c-blue-text: #3730a3;
        }

        /* ğŸŒ™ Dark Mode */
        [data-theme="dark"] {
            --bg-color: #111827;
            --dot-color: #374151;

            --ui-bg: rgba(31, 41, 55, 0.85);
            --ui-border: rgba(255, 255, 255, 0.1);
            --ui-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            --ui-text: #e2e8f0;

            --node-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            --node-shadow-hover: 0 10px 15px -3px rgba(0, 0, 0, 0.4);

            --select-color: #818cf8;
            --group-bg: rgba(129, 140, 248, 0.1);
            --group-border: #4f46e5;
            --link-color: #64748b;

            /* èŠ‚ç‚¹é…è‰² (æ·±è‰²æ¨¡å¼ - é™ä½äº®åº¦ï¼Œæé«˜æ–‡å­—å¯¹æ¯”åº¦) */
            --c-white-bg: #1f2937;
            --c-white-border: #374151;
            --c-white-text: #f3f4f6;
            --c-red-bg: #450a0a;
            --c-red-border: #7f1d1d;
            --c-red-text: #fecaca;
            --c-yellow-bg: #451a03;
            --c-yellow-border: #78350f;
            --c-yellow-text: #fde68a;
            --c-green-bg: #064e3b;
            --c-green-border: #065f46;
            --c-green-text: #a7f3d0;
            --c-blue-bg: #1e1b4b;
            --c-blue-border: #312e81;
            --c-blue-text: #c7d2fe;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(var(--dot-color) 1.5px, transparent 1.5px);
            background-size: 24px 24px;
            color: var(--ui-text);
            user-select: none;
            /* é˜²æ­¢æ‹–æ‹½æ—¶é€‰ä¸­èƒŒæ™¯æ–‡å­— */
            transition: background-color 0.3s, color 0.3s;
        }

        /* --- UI Panel --- */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            width: 44px;
            height: 44px;
            /* å°æ–¹å— */
            border-radius: 12px;
            background: var(--ui-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--ui-border);
            box-shadow: var(--ui-shadow);
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            display: flex;
            flex-direction: column;
            color: var(--ui-text);
        }

        #ui-layer:hover,
        #ui-layer:focus-within {
            width: 320px;
            height: auto;
            border-radius: 16px;
        }

        /* é¡¶éƒ¨ Handle åŒº */
        #ui-top-bar {
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            cursor: default;
        }

        #ui-icon {
            font-size: 24px;
            width: 24px;
            text-align: center;
        }

        /* ğŸ§  emoji */
        #ui-title {
            opacity: 0;
            white-space: nowrap;
            font-weight: 600;
            font-size: 14px;
            margin-left: 10px;
            flex-grow: 1;
            transition: opacity 0.2s;
        }

        #btn-theme {
            opacity: 0;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 18px;
            transition: opacity 0.2s;
        }

        #ui-layer:hover #ui-title,
        #ui-layer:hover #btn-theme,
        #ui-layer:focus-within #ui-title,
        #ui-layer:focus-within #btn-theme {
            opacity: 1;
        }

        /* å†…å®¹åŒº */
        #ui-content {
            padding: 0 15px 15px 15px;
            opacity: 0;
            transition: opacity 0.3s;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        #ui-layer:hover #ui-content,
        #ui-layer:focus-within #ui-content {
            opacity: 1;
        }

        textarea {
            width: 100%;
            height: 80px;
            resize: none;
            border: 1px solid var(--dot-color);
            border-radius: 8px;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            color: inherit;
            outline: none;
            box-sizing: border-box;
            transition: border-color 0.2s;
        }

        textarea:focus {
            border-color: var(--select-color);
        }

        .btn-row {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 10px;
            cursor: pointer;
            background: var(--select-color);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 13px;
            transition: transform 0.1s, opacity 0.2s;
        }

        button:active {
            transform: scale(0.96);
        }

        button:hover {
            opacity: 0.9;
        }

        button.secondary {
            background: transparent;
            color: var(--ui-text);
            border: 1px solid var(--dot-color);
        }

        button.secondary:hover {
            background: rgba(127, 127, 127, 0.1);
        }

        .help-text {
            font-size: 12px;
            color: var(--ui-text);
            opacity: 0.7;
            line-height: 1.6;
            padding-top: 5px;
            border-top: 1px solid var(--dot-color);
        }

        .help-key {
            display: inline-block;
            background: rgba(127, 127, 127, 0.15);
            padding: 0 4px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid rgba(127, 127, 127, 0.2);
            font-size: 11px;
        }

        /* --- Canvas --- */
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            overflow: hidden;
        }

        #world {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }

        /* --- Node Styling --- */
        .node {
            position: absolute;
            border: 1px solid transparent;
            border-radius: 10px;
            padding: 12px 18px;
            min-width: 60px;
            text-align: center;
            box-shadow: var(--node-shadow);
            font-size: 14px;
            cursor: grab;
            white-space: nowrap;
            z-index: 10;
            transition: box-shadow 0.2s, transform 0.1s;
        }

        .node:hover {
            box-shadow: var(--node-shadow-hover);
        }

        .node.selected {
            border: 2px solid var(--select-color);
            z-index: 20;
        }

        /* å…³é”®ä¿®å¤ï¼šç¼–è¾‘æ—¶å…è®¸é€‰ä¸­æ–‡æœ¬ */
        .node.editing {
            cursor: text;
            border-color: var(--select-color);
            outline: none;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
            user-select: text;
            -webkit-user-select: text;
        }

        /* Color Variants using Variables */
        .node.c-white {
            background: var(--c-white-bg);
            border-color: var(--c-white-border);
            color: var(--c-white-text);
        }

        .node.c-red {
            background: var(--c-red-bg);
            border-color: var(--c-red-border);
            color: var(--c-red-text);
        }

        .node.c-yellow {
            background: var(--c-yellow-bg);
            border-color: var(--c-yellow-border);
            color: var(--c-yellow-text);
        }

        .node.c-green {
            background: var(--c-green-bg);
            border-color: var(--c-green-border);
            color: var(--c-green-text);
        }

        .node.c-blue {
            background: var(--c-blue-bg);
            border-color: var(--c-blue-border);
            color: var(--c-blue-text);
        }

        .group {
            position: absolute;
            border: 2px dashed var(--group-border);
            background: var(--group-bg);
            border-radius: 16px;
            z-index: 5;
            pointer-events: all;
            transition: background 0.2s;
        }

        .group.selected {
            border-color: var(--select-color);
            background: rgba(99, 102, 241, 0.15);
        }

        svg.connections {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            z-index: 1;
            pointer-events: none;
        }

        line.link {
            stroke: var(--link-color);
            stroke-width: 2;
            opacity: 0.6;
        }

        #selection-box {
            position: absolute;
            border: 1px solid var(--select-color);
            background: rgba(99, 102, 241, 0.15);
            display: none;
            z-index: 999;
            border-radius: 4px;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div id="ui-top-bar">
            <div id="ui-icon">ğŸ§ </div> <!-- Emoji Icon -->
            <div id="ui-title">Concept Canvas</div>
            <button id="btn-theme" title="åˆ‡æ¢æ·±è‰²/æµ…è‰²æ¨¡å¼">ğŸŒ™</button>
        </div>
        <div id="ui-content">
            <textarea id="input-text" placeholder="è¾“å…¥æƒ³æ³•... (ç©ºæ ¼/é€—å·/æ¢è¡Œåˆ†éš”)"></textarea>
            <button id="btn-add">âœ¨ ç”ŸæˆèŠ‚ç‚¹ (Generate)</button>
            <div class="btn-row">
                <button class="secondary" id="btn-export">å¯¼å‡º</button>
                <button class="secondary" id="btn-import"
                    onclick="document.getElementById('file-input').click()">å¯¼å…¥</button>
                <input type="file" id="file-input" style="display:none" accept=".json">
            </div>
            <div class="help-text">
                <div>ğŸ–±ï¸ <b>ä¸­é”® / ç©ºæ ¼+æ‹–æ‹½</b> å¹³ç§»</div>
                <div>ğŸ–±ï¸ <b>åŒå‡»</b> ç¼–è¾‘ | <b>Ctrl+Click</b> å¤šé€‰</div>
                <div>âŒ¨ï¸ <span class="help-key">Ctrl</span>+<span class="help-key">G</span> ç¼–ç»„ | <span
                        class="help-key">L</span> è¿çº¿</div>
                <div>âŒ¨ï¸ <span class="help-key">Alt</span>+<span class="help-key">1</span>~<span
                        class="help-key">5</span> åˆ‡æ¢é¢œè‰²</div>
                <div>âŒ¨ï¸ <span class="help-key">Del</span> åˆ é™¤ | <span class="help-key">Ctrl</span>+<span
                        class="help-key">D</span> å¤åˆ¶</div>
            </div>
        </div>
    </div>

    <div id="canvas-container">
        <div id="world">
            <svg id="connections-layer" class="connections"></svg>
            <div id="groups-layer"></div>
            <div id="nodes-layer"></div>
        </div>
        <div id="selection-box"></div>
    </div>

    <script>
        // --- State & Config ---
        const state = {
            nodes: [], groups: [], links: [],
            view: { x: window.innerWidth / 2, y: window.innerHeight / 2, scale: 1 },
            selection: new Set(), clipboard: []
        };
        const CONFIG = { colors: ['c-white', 'c-red', 'c-yellow', 'c-green', 'c-blue'] };
        const uid = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

        // --- Theme Logic ---
        const themeBtn = document.getElementById('btn-theme');
        const htmlEl = document.documentElement;
        let isDark = localStorage.getItem('cc-theme') === 'dark';

        function updateTheme() {
            htmlEl.setAttribute('data-theme', isDark ? 'dark' : 'light');
            themeBtn.innerText = isDark ? 'â˜€ï¸' : 'ğŸŒ™';
            localStorage.setItem('cc-theme', isDark ? 'dark' : 'light');
        }
        updateTheme();
        themeBtn.onclick = () => { isDark = !isDark; updateTheme(); };

        // --- DOM Refs ---
        const els = {
            container: document.getElementById('canvas-container'),
            world: document.getElementById('world'),
            nodesLayer: document.getElementById('nodes-layer'),
            groupsLayer: document.getElementById('groups-layer'),
            connectionsLayer: document.getElementById('connections-layer'),
            input: document.getElementById('input-text'),
            selectBox: document.getElementById('selection-box')
        };

        // --- Render System ---
        function render() {
            els.world.style.transform = `translate(${state.view.x}px, ${state.view.y}px) scale(${state.view.scale})`;

            // Links
            els.connectionsLayer.innerHTML = '';
            state.links.forEach(l => {
                const n1 = state.nodes.find(n => n.id === l.sourceId);
                const n2 = state.nodes.find(n => n.id === l.targetId);
                if (n1 && n2) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    const c1 = getNodeCenter(n1); const c2 = getNodeCenter(n2);
                    line.setAttribute('x1', c1.x); line.setAttribute('y1', c1.y);
                    line.setAttribute('x2', c2.x); line.setAttribute('y2', c2.y);
                    line.classList.add('link');
                    els.connectionsLayer.appendChild(line);
                }
            });

            syncDomElements(state.groups, els.groupsLayer, 'group', renderGroup);
            syncDomElements(state.nodes, els.nodesLayer, 'node', renderNode);
        }

        function syncDomElements(dataArray, parent, className, renderFn) {
            const existing = new Map();
            Array.from(parent.children).forEach(el => existing.set(el.dataset.id, el));
            const activeIds = new Set();
            dataArray.forEach(item => {
                activeIds.add(item.id);
                let el = existing.get(item.id);
                if (!el) { el = document.createElement('div'); el.className = className; el.dataset.id = item.id; parent.appendChild(el); }
                renderFn(el, item);
            });
            existing.forEach((el, id) => { if (!activeIds.has(id)) el.remove(); });
        }

        function renderNode(el, node) {
            el.style.transform = `translate(${node.x}px, ${node.y}px)`;
            if (el.innerText !== node.text && !el.isContentEditable) el.innerText = node.text;

            // åŠ¨æ€æ·»åŠ /ç§»é™¤ selected ç±»
            const isSelected = state.selection.has(node.id);
            const classes = ['node', node.color || 'c-white'];
            if (isSelected) classes.push('selected');
            el.className = classes.join(' ');

            if (!node.w || !node.h) requestAnimationFrame(() => { node.w = el.offsetWidth; node.h = el.offsetHeight; });
        }

        function renderGroup(el, group) {
            el.style.transform = `translate(${group.x}px, ${group.y}px)`;
            el.style.width = `${group.w}px`; el.style.height = `${group.h}px`;
            el.className = `group ${state.selection.has(group.id) ? 'selected' : ''}`;
        }
        function getNodeCenter(n) { return { x: n.x + (n.w || 0) / 2, y: n.y + (n.h || 0) / 2 }; }

        // --- Interactions ---
        document.getElementById('btn-add').onclick = () => {
            const text = els.input.value; if (!text.trim()) return;
            const parts = text.split(/[\s,\n]+/).filter(t => t.trim().length > 0);
            const existingTexts = new Set(state.nodes.map(n => n.text));
            const startX = -state.view.x / state.view.scale + window.innerWidth / (2 * state.view.scale);
            const startY = -state.view.y / state.view.scale + window.innerHeight / (2 * state.view.scale);
            let count = 0;
            parts.forEach((str, idx) => {
                if (!existingTexts.has(str)) {
                    state.nodes.push({
                        id: uid(), text: str,
                        x: startX + (count % 5) * 140, y: startY + Math.floor(count / 5) * 80,
                        color: 'c-white'
                    });
                    count++;
                }
            });
            els.input.value = ''; render();
        };

        let dragStart = null;
        let mode = null;
        const keys = {};

        els.container.addEventListener('mousedown', e => {
            // å¤„äºç¼–è¾‘æ¨¡å¼æ—¶ï¼Œç‚¹å‡»å†…éƒ¨ä¸è§¦å‘æ‹–æ‹½
            if (e.target.isContentEditable) return;

            if (e.target.closest('.node') && e.detail === 2) return;
            if (e.button === 1 || (e.button === 0 && keys.Space)) {
                mode = 'pan'; dragStart = { x: e.clientX, y: e.clientY, viewX: state.view.x, viewY: state.view.y };
                return;
            }
            if (e.button === 0) {
                const nodeEl = e.target.closest('.node');
                const groupEl = e.target.closest('.group');
                const worldPos = screenToWorld(e.clientX, e.clientY);
                if (nodeEl) {
                    handleSelection(nodeEl.dataset.id, e.ctrlKey || e.shiftKey);
                    mode = 'move'; dragStart = { x: worldPos.x, y: worldPos.y, initialPos: getSelectionPositions() };
                } else if (groupEl) {
                    handleSelection(groupEl.dataset.id, e.ctrlKey || e.shiftKey);
                    mode = 'move'; dragStart = { x: worldPos.x, y: worldPos.y, initialPos: getSelectionPositions() };
                } else {
                    if (!e.ctrlKey && !e.shiftKey) state.selection.clear();
                    mode = 'box'; dragStart = { x: e.clientX, y: e.clientY };
                    els.selectBox.style.display = 'block';
                    updateSelectBox(e.clientX, e.clientY, e.clientX, e.clientY);
                    render();
                }
            }
        });

        els.container.addEventListener('mousemove', e => {
            if (!mode) return;
            if (mode === 'pan') {
                state.view.x = dragStart.viewX + (e.clientX - dragStart.x);
                state.view.y = dragStart.viewY + (e.clientY - dragStart.y);
                render();
            } else if (mode === 'move') {
                const worldPos = screenToWorld(e.clientX, e.clientY);
                const dx = worldPos.x - dragStart.x;
                const dy = worldPos.y - dragStart.y;
                state.selection.forEach(id => {
                    const init = dragStart.initialPos[id];
                    if (init) {
                        const item = findItem(id);
                        if (item) {
                            item.x = init.x + dx; item.y = init.y + dy;
                            if (init.type === 'group') {
                                item.memberIds.forEach(mid => {
                                    const member = state.nodes.find(n => n.id === mid);
                                    if (member && !dragStart.initialPos[mid]) {
                                        const mInit = dragStart.initialPos[`member_${mid}`];
                                        if (mInit) { member.x = mInit.x + dx; member.y = mInit.y + dy; }
                                    }
                                });
                            }
                        }
                    }
                });
                render();
            } else if (mode === 'box') {
                updateSelectBox(dragStart.x, dragStart.y, e.clientX, e.clientY);
            }
        });

        els.container.addEventListener('mouseup', e => {
            if (mode === 'box') {
                const rect = getStandardRect(dragStart.x, dragStart.y, e.clientX, e.clientY);
                const worldRect = {
                    x: (rect.x - state.view.x) / state.view.scale, y: (rect.y - state.view.y) / state.view.scale,
                    w: rect.w / state.view.scale, h: rect.h / state.view.scale
                };
                [...state.nodes, ...state.groups].forEach(item => { if (isIntersect(worldRect, item)) state.selection.add(item.id); });
                els.selectBox.style.display = 'none';
                render();
            }
            mode = null; dragStart = null;
        });

        els.container.addEventListener('wheel', e => {
            e.preventDefault();
            const factor = 1 + ((e.deltaY > 0 ? -1 : 1) * 0.1);
            const worldX = (e.clientX - state.view.x) / state.view.scale;
            const worldY = (e.clientY - state.view.y) / state.view.scale;
            state.view.scale = Math.max(0.1, Math.min(5, state.view.scale * factor));
            state.view.x = e.clientX - worldX * state.view.scale;
            state.view.y = e.clientY - worldY * state.view.scale;
            render();
        }, { passive: false });

        // Double Click Edit
        els.container.addEventListener('dblclick', e => {
            const nodeEl = e.target.closest('.node');
            if (nodeEl) {
                const node = state.nodes.find(n => n.id === nodeEl.dataset.id);
                if (node) {
                    nodeEl.contentEditable = true;
                    nodeEl.classList.add('editing');
                    nodeEl.focus();
                    // åˆå§‹é€‰ä¸­å…¨éƒ¨ï¼Œä½†å…è®¸åç»­ç‚¹å‡»ä¿®æ”¹å…‰æ ‡ä½ç½®
                    const range = document.createRange(); range.selectNodeContents(nodeEl);
                    const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);

                    const finishEdit = () => {
                        nodeEl.contentEditable = false; nodeEl.classList.remove('editing');
                        node.text = nodeEl.innerText;
                        node.w = nodeEl.offsetWidth; node.h = nodeEl.offsetHeight;
                        render();
                    };
                    nodeEl.onblur = finishEdit;
                    nodeEl.onkeydown = (ev) => {
                        if (ev.key === 'Enter') { ev.preventDefault(); nodeEl.blur(); }
                        ev.stopPropagation(); // é˜»æ­¢æŒ‰é”®å†’æ³¡è§¦å‘å¿«æ·é”®
                    };
                }
            }
        });

        // Keys
        window.addEventListener('keydown', e => {
            if (e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
            keys[e.code] = true;

            if (e.code === 'Space') e.preventDefault();
            if (e.ctrlKey && e.code === 'KeyG' && !e.shiftKey) { e.preventDefault(); createGroup(); }
            if (e.ctrlKey && e.shiftKey && e.code === 'KeyG') { e.preventDefault(); dissolveGroup(); }
            if (e.ctrlKey && e.code === 'KeyL') { e.preventDefault(); toggleLink(); }
            if (e.code === 'Delete') deleteSelection();
            if (e.ctrlKey && e.code === 'KeyD') { e.preventDefault(); duplicateSelection(); }
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) { e.preventDefault(); nudgeSelection(e.code); }

            // Alt + 1~5 for Colors
            if (e.altKey && ['Digit1', 'Digit2', 'Digit3', 'Digit4', 'Digit5'].includes(e.code)) {
                e.preventDefault();
                colorSelection(CONFIG.colors[parseInt(e.key) - 1]);
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Helpers
        function screenToWorld(sx, sy) { return { x: (sx - state.view.x) / state.view.scale, y: (sy - state.view.y) / state.view.scale }; }
        function handleSelection(id, multi) {
            if (!multi) { if (!state.selection.has(id)) { state.selection.clear(); state.selection.add(id); } }
            else { if (state.selection.has(id)) state.selection.delete(id); else state.selection.add(id); }
            render();
        }
        function getSelectionPositions() {
            const pos = {};
            state.selection.forEach(id => {
                const item = findItem(id);
                if (item) {
                    pos[id] = { x: item.x, y: item.y, type: item.text ? 'node' : 'group' };
                    if (!item.text && item.memberIds) {
                        item.memberIds.forEach(mid => { const m = state.nodes.find(n => n.id === mid); if (m) pos[`member_${mid}`] = { x: m.x, y: m.y }; });
                    }
                }
            });
            return pos;
        }
        function findItem(id) { return state.nodes.find(n => n.id === id) || state.groups.find(g => g.id === id); }
        function updateSelectBox(x1, y1, x2, y2) {
            const r = getStandardRect(x1, y1, x2, y2);
            els.selectBox.style.left = r.x + 'px'; els.selectBox.style.top = r.y + 'px';
            els.selectBox.style.width = r.w + 'px'; els.selectBox.style.height = r.h + 'px';
        }
        function getStandardRect(x1, y1, x2, y2) { return { x: Math.min(x1, x2), y: Math.min(y1, y2), w: Math.abs(x1 - x2), h: Math.abs(y1 - y2) }; }
        function isIntersect(r1, r2) {
            const r2w = r2.w || 100; const r2h = r2.h || 40;
            return !(r2.x > r1.x + r1.w || r2.x + r2w < r1.x || r2.y > r1.y + r1.h || r2.y + r2h < r1.y);
        }
        function createGroup() {
            const selectedNodes = state.nodes.filter(n => state.selection.has(n.id));
            if (selectedNodes.length === 0) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            selectedNodes.forEach(n => {
                minX = Math.min(minX, n.x); minY = Math.min(minY, n.y);
                maxX = Math.max(maxX, n.x + (n.w || 0)); maxY = Math.max(maxY, n.y + (n.h || 0));
            });
            const padding = 20;
            const group = { id: uid(), x: minX - padding, y: minY - padding, w: maxX - minX + padding * 2, h: maxY - minY + padding * 2, memberIds: selectedNodes.map(n => n.id) };
            state.groups.push(group); state.selection.clear(); state.selection.add(group.id); render();
        }
        function dissolveGroup() {
            const toRemove = [];
            state.selection.forEach(id => { const idx = state.groups.findIndex(g => g.id === id); if (idx !== -1) toRemove.push(idx); });
            toRemove.sort((a, b) => b - a).forEach(idx => state.groups.splice(idx, 1));
            if (toRemove.length > 0) { state.selection.clear(); render(); }
        }
        function toggleLink() {
            const sel = Array.from(state.selection);
            const nodes = sel.map(id => state.nodes.find(n => n.id === id)).filter(n => n);
            if (nodes.length !== 2) return;
            const [n1, n2] = nodes;
            const existingIdx = state.links.findIndex(l => (l.sourceId === n1.id && l.targetId === n2.id) || (l.sourceId === n2.id && l.targetId === n1.id));
            if (existingIdx !== -1) state.links.splice(existingIdx, 1); else state.links.push({ id: uid(), sourceId: n1.id, targetId: n2.id });
            render();
        }
        function deleteSelection() {
            const sel = state.selection;
            state.nodes = state.nodes.filter(n => !sel.has(n.id));
            state.groups = state.groups.filter(g => !sel.has(g.id));
            state.links = state.links.filter(l => !sel.has(l.sourceId) && !sel.has(l.targetId));
            state.groups.forEach(g => { g.memberIds = g.memberIds.filter(mid => state.nodes.find(n => n.id === mid)); });
            state.selection.clear(); render();
        }
        function duplicateSelection() {
            const newSelection = new Set(); const mapping = {};
            state.nodes.forEach(n => {
                if (state.selection.has(n.id)) {
                    const newNode = { ...n, id: uid(), x: n.x + 20, y: n.y + 20 };
                    state.nodes.push(newNode); newSelection.add(newNode.id); mapping[n.id] = newNode.id;
                }
            });
            state.groups.forEach(g => {
                if (state.selection.has(g.id)) {
                    const newGroup = { ...g, id: uid(), x: g.x + 20, y: g.y + 20 };
                    newGroup.memberIds = g.memberIds.map(mid => mapping[mid] || mid);
                    state.groups.push(newGroup); newSelection.add(newGroup.id);
                }
            });
            state.selection = newSelection; render();
        }
        function nudgeSelection(key) {
            const step = 10; let dx = 0, dy = 0;
            if (key === 'ArrowUp') dy = -step; if (key === 'ArrowDown') dy = step;
            if (key === 'ArrowLeft') dx = -step; if (key === 'ArrowRight') dx = step;
            state.selection.forEach(id => {
                const item = findItem(id);
                if (item) {
                    item.x += dx; item.y += dy;
                    if (!item.text && item.memberIds) item.memberIds.forEach(mid => { const m = state.nodes.find(n => n.id === mid); if (m) { m.x += dx; m.y += dy; } });
                }
            });
            render();
        }
        function colorSelection(colorClass) { state.nodes.forEach(n => { if (state.selection.has(n.id)) n.color = colorClass; }); render(); }

        document.getElementById('btn-export').onclick = () => {
            const blob = new Blob([JSON.stringify({ nodes: state.nodes, groups: state.groups, links: state.links }, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob); const a = document.createElement('a');
            a.href = url; a.download = 'canvas-v3.json'; a.click(); URL.revokeObjectURL(url);
        };
        document.getElementById('file-input').onchange = (e) => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try { const data = JSON.parse(ev.target.result); state.nodes = data.nodes || []; state.groups = data.groups || []; state.links = data.links || []; state.selection.clear(); render(); }
                catch (err) { alert('æ–‡ä»¶æ ¼å¼é”™è¯¯'); }
            };
            reader.readAsText(file); e.target.value = '';
        };

        render();
    </script>
</body>

</html>